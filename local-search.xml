<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>go 标准库的 heap</title>
    <link href="/2021/01/31/go-%E6%A0%87%E5%87%86%E5%BA%93%E6%BA%90%E7%A0%81-heap/"/>
    <url>/2021/01/31/go-%E6%A0%87%E5%87%86%E5%BA%93%E6%BA%90%E7%A0%81-heap/</url>
    
    <content type="html"><![CDATA[<p>go 标准库提供的 <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">堆</a> 虽然在 <a href="https://github.com/golang/go/tree/master/src/container/heap"><code>container</code></a> 包里，但它其实并没有像 <code>list</code> 和 <code>ring</code> 那样提供一个实实在在的容器，事实上它定义了一个如下的接口和一系列堆的基本操作，只要是实现了该接口的结构就可以被认为是一个堆，从而把堆的操作方法用到该结构上。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> &#123;    <span class="hljs-comment">// 排序接口</span>    sort.Interface    <span class="hljs-comment">// 追加元素</span>    Push(x <span class="hljs-keyword">interface</span>&#123;&#125;)    <span class="hljs-comment">// 移除首个元素</span>    Pop() <span class="hljs-keyword">interface</span>&#123;&#125;&#125;</code></pre><p><strong>注意</strong> <code>Interface</code> 中的 <code>Push</code> 和 <code>Pop</code> 方法是针对要实现该接口的数据接口本身的追加和移除操作，并非我们通常说的堆的 <code>Push</code> 和 <code>Pop</code> 方法，在使用堆时切记使用的是 <code>heap.Push(h, x)</code> 和 <code>heap.Pop(h)</code> 。</p><h2 id="堆的初始化"><a href="#堆的初始化" class="headerlink" title="堆的初始化"></a>堆的初始化</h2><pre><code class="hljs go"><span class="hljs-comment">// 把给定的结构初始化成一个 最小堆</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Init</span><span class="hljs-params">(h Interface)</span></span> &#123;    n := h.Len()    <span class="hljs-comment">// i = n / 2 - 1</span>    <span class="hljs-comment">// 2i + 1 = n - 1 =&gt; i 是 非叶子节点</span>    <span class="hljs-comment">// 对所有非叶子节点进行下沉操作</span>    <span class="hljs-keyword">for</span> i := n/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;        down(h, i, n)    &#125;&#125;<span class="hljs-comment">// 节点下沉操作</span><span class="hljs-comment">// n: 下沉操作的界限</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">down</span><span class="hljs-params">(h Interface, i0, n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;    i := i0    <span class="hljs-keyword">for</span> &#123;        j1 := <span class="hljs-number">2</span>*i + <span class="hljs-number">1</span>        <span class="hljs-comment">// 下沉是考虑的节点不超过 n</span>        <span class="hljs-comment">// 可以观察下 Init/Fix 和 Pop/Remove 时 n 的值</span>        <span class="hljs-keyword">if</span> j1 &gt;= n || j1 &lt; <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// j1 &lt; 0 after int overflow</span>            <span class="hljs-keyword">break</span>        &#125;        j := j1 <span class="hljs-comment">// left child</span>        <span class="hljs-comment">// 选出左、右子节点中较小的</span>        <span class="hljs-keyword">if</span> j2 := j1 + <span class="hljs-number">1</span>; j2 &lt; n &amp;&amp; h.Less(j2, j1) &#123;            j = j2 <span class="hljs-comment">// = 2*i + 2  // right child</span>        &#125;        <span class="hljs-keyword">if</span> !h.Less(j, i) &#123;            <span class="hljs-comment">// 子节点不小于父节点 (已经是有序的)</span>            <span class="hljs-keyword">break</span>        &#125;        <span class="hljs-comment">// 父节点与左、右子节点中较小的进行交换</span>        h.Swap(i, j)        <span class="hljs-comment">// 原来的父节点已经变为子节点，考虑是否还要继续下沉</span>        i = j    &#125;    <span class="hljs-comment">// 返回 i0 节点是否下沉了</span>    <span class="hljs-keyword">return</span> i &gt; i0&#125;</code></pre><h2 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h2><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Push</span><span class="hljs-params">(h Interface, x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;    h.Push(x)    <span class="hljs-comment">// 添加的元素是堆对应二叉树的最右下的节点</span>    <span class="hljs-comment">// 考虑该元素是否需要上浮</span>    up(h, h.Len()<span class="hljs-number">-1</span>)&#125;<span class="hljs-comment">// 元素上浮操作</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">up</span><span class="hljs-params">(h Interface, j <span class="hljs-keyword">int</span>)</span></span> &#123;    <span class="hljs-keyword">for</span> &#123;        i := (j - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> <span class="hljs-comment">// parent</span>        <span class="hljs-keyword">if</span> i == j || !h.Less(j, i) &#123;            <span class="hljs-comment">// 该元素不小于父节点</span>            <span class="hljs-keyword">break</span>        &#125;        <span class="hljs-comment">// 与父节点交换</span>        h.Swap(i, j)        <span class="hljs-comment">// 考虑是否需要继续上浮</span>        j = i    &#125;&#125;</code></pre><h2 id="弹出元素与移除某个元素"><a href="#弹出元素与移除某个元素" class="headerlink" title="弹出元素与移除某个元素"></a>弹出元素与移除某个元素</h2><pre><code class="hljs go"><span class="hljs-comment">// 移除堆的根节点</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pop</span><span class="hljs-params">(h Interface)</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;    n := h.Len() - <span class="hljs-number">1</span>    <span class="hljs-comment">// 根节点与最后一个（最右下）元素交换</span>    h.Swap(<span class="hljs-number">0</span>, n)    <span class="hljs-comment">// 对交换后的根节点进行下沉操作</span>    <span class="hljs-comment">// 注意下沉时的界限为 倒数第二个 元素 （不包括最后一个元素，否则就白交换了）</span>    down(h, <span class="hljs-number">0</span>, n)    <span class="hljs-comment">// 移除最后一个元素，即原来的根节点</span>    <span class="hljs-keyword">return</span> h.Pop()&#125;<span class="hljs-comment">// 移除堆的第 n 个节点</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Remove</span><span class="hljs-params">(h Interface, i <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;    n := h.Len() - <span class="hljs-number">1</span>    <span class="hljs-comment">// 如果是最后一个节点的话直接移除</span>    <span class="hljs-keyword">if</span> n != i &#123;        h.Swap(i, n)        <span class="hljs-keyword">if</span> !down(h, i, n) &#123;            <span class="hljs-comment">// 交换、下沉与 Pop 类似</span>            <span class="hljs-comment">// 因为 i 不一定是根节点，如果有下沉操作的话还要考虑是否要进行上浮</span>            up(h, i)        &#125;    &#125;    <span class="hljs-keyword">return</span> h.Pop()&#125;</code></pre><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><pre><code class="hljs go"><span class="hljs-comment">// 节点 i 的值发生变化后需要对堆进行修复</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fix</span><span class="hljs-params">(h Interface, i <span class="hljs-keyword">int</span>)</span></span> &#123;    <span class="hljs-comment">// 先下沉</span>    <span class="hljs-keyword">if</span> !down(h, i, h.Len()) &#123;        <span class="hljs-comment">// 如果有下沉操作则考虑上浮</span>        up(h, i)    &#125;&#125;</code></pre><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>使用堆实现 <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra’s algorithm</a> 来解决 <a href="https://leetcode-cn.com/problems/path-with-minimum-effort/">Leetcode 1631. 最小体力消耗路径</a> 问题：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> node <span class="hljs-keyword">struct</span> &#123;    x, y, distance <span class="hljs-keyword">int</span>&#125;<span class="hljs-comment">// 定义堆</span><span class="hljs-keyword">type</span> nodeHeap []*node<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h nodeHeap)</span> <span class="hljs-title">Len</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h nodeHeap)</span> <span class="hljs-title">Less</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;    <span class="hljs-keyword">return</span> h[i].distance &lt; h[j].distance&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h nodeHeap)</span> <span class="hljs-title">Swap</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span></span> &#123;    h[i], h[j] = h[j], h[i]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *nodeHeap)</span> <span class="hljs-title">Pop</span><span class="hljs-params">()</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;    tail := <span class="hljs-built_in">len</span>(*h) - <span class="hljs-number">1</span>    x := (*h)[tail]    *h = (*h)[<span class="hljs-number">0</span>:tail]    <span class="hljs-keyword">return</span> x&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *nodeHeap)</span> <span class="hljs-title">Push</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;    *h = <span class="hljs-built_in">append</span>(*h, x.(*node))&#125;<span class="hljs-comment">// 4 个方向</span><span class="hljs-keyword">var</span> direct = [<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;    &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,    &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;,    &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,    &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;,&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;    <span class="hljs-keyword">if</span> x &gt; y &#123;        <span class="hljs-keyword">return</span> x    &#125;    <span class="hljs-keyword">return</span> y&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> &#123;        <span class="hljs-keyword">return</span> -x    &#125;    <span class="hljs-keyword">return</span> x&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minimumEffortPath</span><span class="hljs-params">(heights [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;    <span class="hljs-keyword">const</span> infinity = <span class="hljs-number">10000000</span>    m, n := <span class="hljs-built_in">len</span>(heights), <span class="hljs-built_in">len</span>(heights[<span class="hljs-number">0</span>])    maxDis := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, m)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;m;i++&#123;        maxDis[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n)        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;n;j++&#123;            maxDis[i][j] = infinity        &#125;    &#125;    nh := &amp;nodeHeap&#123;&#123;        x: <span class="hljs-number">0</span>,        y: <span class="hljs-number">0</span>,    &#125;&#125;    heap.Init(nh)    <span class="hljs-keyword">for</span> &#123;        p := heap.Pop(nh).(*node)        <span class="hljs-keyword">if</span> p.x == m<span class="hljs-number">-1</span> &amp;&amp; p.y == n<span class="hljs-number">-1</span> &#123;            <span class="hljs-keyword">return</span> p.distance        &#125;        <span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> direct &#123;            x, y := p.x + d[<span class="hljs-number">0</span>], p.y + d[<span class="hljs-number">1</span>]            <span class="hljs-keyword">if</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; n &#123;                d := max(p.distance, abs(heights[p.x][p.y] - heights[x][y]))                <span class="hljs-keyword">if</span> d &lt; maxDis[x][y] &#123;                    maxDis[x][y] = d                    heap.Push(nh, &amp;node&#123;                        x: x,                        y: y,                        distance: d,                    &#125;)                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码</tag>
      
      <tag>golang</tag>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sync.Once中的快速路径</title>
    <link href="/2021/01/24/sync-Once%E4%B8%AD%E7%9A%84%E5%BF%AB%E9%80%9F%E8%B7%AF%E5%BE%84/"/>
    <url>/2021/01/24/sync-Once%E4%B8%AD%E7%9A%84%E5%BF%AB%E9%80%9F%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<p><code>sync.Once</code> 的 <a href="https://github.com/golang/go/blob/b634f5d97a6e65f19057c00ed2095a1a872c7fa8/src/sync/once.go#L42"><code>Do</code></a> 方法中有这样一个技巧：先用原子操作 <strong>快速</strong> 判断是否执行过, 如果没有执行过（<code>done == 0</code>）再加锁执行 <code>f</code> 方法。</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span> <span class="hljs-title">Do</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>()</span>)</span> &#123;    <span class="hljs-keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="hljs-number">0</span> &#123;        o.doSlow(f)    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span> <span class="hljs-title">doSlow</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>()</span>)</span> &#123;    o.m.Lock()    <span class="hljs-keyword">defer</span> o.m.Unlock()    <span class="hljs-keyword">if</span> o.done == <span class="hljs-number">0</span> &#123;        <span class="hljs-keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="hljs-number">1</span>)        f()    &#125;&#125;</code></pre><p>其实这里完全可以直接执行 <code>doSlow</code> 方法，因为它内部已经加锁了，即便有并发执行也不会有任何问题。</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span> <span class="hljs-title">Do</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>()</span>)</span> &#123;    o.m.Lock()    <span class="hljs-keyword">defer</span> o.m.Unlock()    <span class="hljs-keyword">if</span> o.done == <span class="hljs-number">0</span> &#123;        <span class="hljs-keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="hljs-number">1</span>)        f()    &#125;&#125;</code></pre><p>之所以要多此一举是因为 <strong>原子操作的性能要优于加锁</strong> ，对于 <code>Do</code> 方法来说，大部分调用 <code>done</code> 都是不等于 0 的，因此这样做避免了对大部分的调用进行加锁判断（只有最初的 <strong>一次或几次并发调用</strong> 会进入到 <code>doSlow</code> 方法），是一种非常经典的编程范式。</p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码</tag>
      
      <tag>golang</tag>
      
      <tag>编程范式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes 源码阅读 -- Expiring</title>
    <link href="/2021/01/02/Kubernetes-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-Expiring/"/>
    <url>/2021/01/02/Kubernetes-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-Expiring/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/cache/expiring.go"><code>Expiring</code></a> 是 Kubernets 中的一个 <strong>带有过期时间的键值对缓存</strong>，位于 <code>k8s.io/apimachinery</code> 模块的 <code>pkg/util/cache</code> 包中。</p><p><code>Expiring</code> 具有以下功能与特性：</p><ul><li>可以存取任意类型的键值对</li><li>键值对在过期后会被自动清除</li><li>线程安全</li></ul><pre><code class="hljs Go"><span class="hljs-comment">// 添加带过期时间的键值对</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Expiring)</span> <span class="hljs-title">Set</span><span class="hljs-params">(key <span class="hljs-keyword">interface</span>&#123;&#125;, val <span class="hljs-keyword">interface</span>&#123;&#125;, ttl time.Duration)</span></span><span class="hljs-comment">// 根据 key 获取 value</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Expiring)</span> <span class="hljs-title">Get</span><span class="hljs-params">(key <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(val <span class="hljs-keyword">interface</span>&#123;&#125;, ok <span class="hljs-keyword">bool</span>)</span></span><span class="hljs-comment">// 根据 key 删除键值对</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Expiring)</span> <span class="hljs-title">Delete</span><span class="hljs-params">(key <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><span class="hljs-comment">// 获取 Expiring 中存储的键值对数量</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Expiring)</span> <span class="hljs-title">Len</span><span class="hljs-params">()</span></span></code></pre><h2 id="Expiring-的数据结构"><a href="#Expiring-的数据结构" class="headerlink" title="Expiring 的数据结构"></a>Expiring 的数据结构</h2><p>基于上述的功能与特性，<code>Expiring</code> 提供了以下方法：</p><p><code>Expiring</code> 的数据结构设计如下：</p><pre><code class="hljs Go"><span class="hljs-keyword">type</span> Expiring <span class="hljs-keyword">struct</span> &#123;    <span class="hljs-comment">// 时钟接口，使用该接口主要是为了便于测试</span>    <span class="hljs-comment">// 在 Expiring 中用到其中的 Now 方法，该方法可以直接看作 time.Now</span>    clock utilclock.Clock    <span class="hljs-comment">// 读写锁，用于保证线程安全</span>    mu sync.RWMutex    <span class="hljs-comment">// 实际存储键值对的数据结构</span>    cache <span class="hljs-keyword">map</span>[<span class="hljs-keyword">interface</span>&#123;&#125;]entry    <span class="hljs-comment">// 全局版本号，用来实现键值对过期时间的更新</span>    generation <span class="hljs-keyword">uint64</span>    <span class="hljs-comment">// 存储过期时间的最小堆</span>    heap expiringHeap&#125;</code></pre><p>其中 <code>entry</code> 的数据结构如下：</p><pre><code class="hljs Go"><span class="hljs-keyword">type</span> entry <span class="hljs-keyword">struct</span> &#123;    <span class="hljs-comment">// 用户输入的 value</span>    val        <span class="hljs-keyword">interface</span>&#123;&#125;    <span class="hljs-comment">// 用户指定的过期时间</span>    expiry     time.Time    <span class="hljs-comment">// 存储当前键值对时 Expiring 的版本号</span>    generation <span class="hljs-keyword">uint64</span>&#125;</code></pre><h3 id="expiringHeap"><a href="#expiringHeap" class="headerlink" title="expiringHeap"></a>expiringHeap</h3><p><a href="https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/cache/expiring.go#L168"><code>expiringHeap</code></a> 是一个存储键值对过期时间的最小堆，其数据结构如下：</p><pre><code class="hljs Go"><span class="hljs-keyword">type</span> expiringHeap []*expiringHeapEntry<span class="hljs-keyword">type</span> expiringHeapEntry <span class="hljs-keyword">struct</span> &#123;    <span class="hljs-comment">// 用户输入的 key</span>    key        <span class="hljs-keyword">interface</span>&#123;&#125;    <span class="hljs-comment">// 过期时间</span>    expiry     time.Time    <span class="hljs-comment">// 存储当前键值对时 Expiring 的版本号</span>    generation <span class="hljs-keyword">uint64</span>&#125;<span class="hljs-comment">// expiringHeap 实现了 heap.Interface 接口</span><span class="hljs-comment">// 即可以当作堆来使用</span><span class="hljs-keyword">var</span> _ heap.Interface = &amp;expiringHeap&#123;&#125;<span class="hljs-comment">// 比较的是过期时间</span><span class="hljs-comment">// expiringHeapEntry 中的元素 i 小于 元素 j 当且仅当 i 的过期时间小于 j 的过期时间</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cq expiringHeap)</span> <span class="hljs-title">Less</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;    <span class="hljs-keyword">return</span> cq[i].expiry.Before(cq[j].expiry)&#125;<span class="hljs-comment">// heap.Interface 的其它方法的实现较为常见，在此忽略</span></code></pre><h2 id="Expiring-的实现"><a href="#Expiring-的实现" class="headerlink" title="Expiring 的实现"></a>Expiring 的实现</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Expiring)</span> <span class="hljs-title">Set</span><span class="hljs-params">(key <span class="hljs-keyword">interface</span>&#123;&#125;, val <span class="hljs-keyword">interface</span>&#123;&#125;, ttl time.Duration)</span></span> &#123;    <span class="hljs-comment">// 计算超时时间</span>    now := c.clock.Now()    expiry := now.Add(ttl)    <span class="hljs-comment">// 加写锁保证线程安全</span>    c.mu.Lock()    <span class="hljs-keyword">defer</span> c.mu.Unlock()    <span class="hljs-comment">// 全局版本号自增</span>    c.generation++    <span class="hljs-comment">// 存储 value</span>    c.cache[key] = entry&#123;        val:        val,        expiry:     expiry,        generation: c.generation,    &#125;    <span class="hljs-comment">// 清理已过期的键值对</span>    <span class="hljs-comment">// Run GC inline before pushing the new entry.</span>    c.gc(now)    <span class="hljs-comment">// 过期时间存入最小堆中</span>    heap.Push(&amp;c.heap, &amp;expiringHeapEntry&#123;        key:        key,        expiry:     expiry,        generation: c.generation,    &#125;)&#125;</code></pre><h4 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h4><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Expiring)</span> <span class="hljs-title">Get</span><span class="hljs-params">(key <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(val <span class="hljs-keyword">interface</span>&#123;&#125;, ok <span class="hljs-keyword">bool</span>)</span></span> &#123;    <span class="hljs-comment">// 加读锁保证线程安全</span>    c.mu.RLock()    <span class="hljs-keyword">defer</span> c.mu.RUnlock()    e, ok := c.cache[key]    <span class="hljs-keyword">if</span> !ok || !c.clock.Now().Before(e.expiry) &#123;        <span class="hljs-comment">// 如果键值对存在但已过期则当作不存在返回</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">return</span> e.val, <span class="hljs-literal">true</span>&#125;</code></pre><h3 id="清理过期的键值对"><a href="#清理过期的键值对" class="headerlink" title="清理过期的键值对"></a>清理过期的键值对</h3><pre><code class="hljs Go"><span class="hljs-comment">// 将 Expiring 所有过期的键值对清除</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Expiring)</span> <span class="hljs-title">gc</span><span class="hljs-params">(now time.Time)</span></span> &#123;    <span class="hljs-keyword">for</span> &#123;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c.heap) == <span class="hljs-number">0</span> || now.Before(c.heap[<span class="hljs-number">0</span>].expiry) &#123;            <span class="hljs-comment">// 因为过期时间的 entry 以最小堆的形式组织</span>            <span class="hljs-comment">// 所以如果第一个元素没有过期的话其余的元素也肯定没有过期</span>            <span class="hljs-keyword">return</span>        &#125;        cleanup := heap.Pop(&amp;c.heap).(*expiringHeapEntry)        <span class="hljs-comment">// 执行清理操作</span>        c.del(cleanup.key, cleanup.generation)    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Expiring)</span> <span class="hljs-title">del</span><span class="hljs-params">(key <span class="hljs-keyword">interface</span>&#123;&#125;, generation <span class="hljs-keyword">uint64</span>)</span></span> &#123;    e, ok := c.cache[key]    <span class="hljs-keyword">if</span> !ok &#123;        <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-comment">// generation == 0 标识该方法是由 Delete 调用的，键值对一定需要删除</span>    <span class="hljs-comment">// generation != 0 则说明该方法由 gc 调用</span>    <span class="hljs-comment">//      当 gc 调用该方法时如果该键值对在 cache 中存储的过期时间与在最小堆中存储的版本号不一致则说明</span>    <span class="hljs-comment">//      该键值对被更新过，当前的过期时间 entry 已经无效了，忽略就行（堆中还存在着该键值对的其它过期时间 entry）</span>    <span class="hljs-keyword">if</span> generation != <span class="hljs-number">0</span> &amp;&amp; generation != e.generation &#123;        <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-built_in">delete</span>(c.cache, key)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Expiring)</span> <span class="hljs-title">Delete</span><span class="hljs-params">(key <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;    c.mu.Lock()    <span class="hljs-keyword">defer</span> c.mu.Unlock()    c.del(key, <span class="hljs-number">0</span>)&#125;</code></pre><h3 id="utilclock-Clock"><a href="#utilclock-Clock" class="headerlink" title="utilclock.Clock"></a>utilclock.Clock</h3><p>在测试 <code>Expiring</code> 时，添加键值对需要指定过期时间，这可能导致测试时间变得很长，<br><code>Expiring</code> 中引入 <a href="https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/clock/clock.go"><code>utilclock.Clock</code></a> 能够让测试变得更加简单迅速。</p><p>在实际使用时，<code>Expiring</code> 使用的是 <a href="https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/clock/clock.go#L43"><code>RealClock</code></a>，它使用的是真实的时间。</p><p>而在测试时则可以使用 <a href="https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/clock/clock.go#L85"><code>FakeClock</code></a> 来 “快进” 到任意时间。</p><p>下一篇文章将对 <code>Clock</code> 进行详细的介绍。</p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>源码</tag>
      
      <tag>cache</tag>
      
      <tag>apimachinery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes 源码阅读 -- Indexer</title>
    <link href="/2020/10/22/Kubernetes-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-Indexer/"/>
    <url>/2020/10/22/Kubernetes-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-Indexer/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://github.com/kubernetes/client-go/blob/d1a4fe5f2d96df815903781843870155cb4f5f40/tools/cache/index.go#L35"><code>Indexer</code></a> 是 kubernetes 中用于在内存中缓存资源对象的接口，支持通过 Key 对存储的资源对象进行增、删、查、改操作， 同时也可以对存储的对象进行倒排索引。</p><p><code>cache</code> 是 <code>Indexer</code> 的实现方式，其定义如下：</p><pre><code class="hljs Go"><span class="hljs-keyword">type</span> cache <span class="hljs-keyword">struct</span> &#123;    cacheStorage    ThreadSafeStore    keyFunc         KeyFunc&#125;</code></pre><p><code>ThreadSafeStore</code> 定义了一个线程安全的存储接口，由 <code>threadSafeMap</code> 实现。</p><p>ThreadSafeStore 与 Indexer 非常相似，前者可以看作是后者的一种特例。ThreadSafeStore 操作资源对象时需要指定对象的 key，而 Indexer 则不需要，是在 Indexer 的实现结构 cache 中通过 <code>keyFunc</code> 动态计算资源对象的 key。因此可以认为 <code>Indexer = ThreadSafeStore + KeyFunc</code>。</p><h2 id="Indexer"><a href="#Indexer" class="headerlink" title="Indexer"></a>Indexer</h2><p>Indexer 与其它数据结构的关系如下：<br><img src="http://lc-c7oxru7u.cn-n1.lcfile.com/c34bc3865ff4230a648a.png/diagram-16025179975213868166.png" alt="Indexer UML"></p><p>从图中可以看出没有索引的 cache 就是一个 Store，源码中 Indexer 和 Store 的创建方式分别如下：</p><pre><code class="hljs GO"><span class="hljs-comment">// NewStore returns a Store implemented simply with a map and a lock.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewStore</span><span class="hljs-params">(keyFunc KeyFunc)</span> <span class="hljs-title">Store</span></span> &#123;    <span class="hljs-keyword">return</span> &amp;cache&#123;        cacheStorage: NewThreadSafeStore(Indexers&#123;&#125;, Indices&#123;&#125;),        keyFunc:      keyFunc,    &#125;&#125;<span class="hljs-comment">// NewIndexer returns an Indexer implemented simply with a map and a lock.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewIndexer</span><span class="hljs-params">(keyFunc KeyFunc, indexers Indexers)</span> <span class="hljs-title">Indexer</span></span> &#123;    <span class="hljs-keyword">return</span> &amp;cache&#123;        cacheStorage: NewThreadSafeStore(indexers, Indices&#123;&#125;),        keyFunc:      keyFunc,    &#125;<span class="hljs-keyword">type</span> KeyFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, error)</span></span></code></pre><p><code>ThreadSafeStore</code> 通过 <code>indexers</code> 创建索引，indexers 是一个如下的 map：</p><pre><code class="hljs GO"><span class="hljs-keyword">type</span> Indexers <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]IndexFunc<span class="hljs-keyword">type</span> IndexFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">([]<span class="hljs-keyword">string</span>, error)</span></span></code></pre><p>Indexers 的 Key 是索引名称，值是 <em>根据资源对象创建计算该索引的索引值的函数</em></p><p><code>Indices</code> 是存储倒排索引的数据结构：</p><pre><code class="hljs Go"><span class="hljs-keyword">type</span> Indices <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]Index<span class="hljs-keyword">type</span> Index <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]sets.String</code></pre><p>Indices 的 Key 是索引名, 值是对应的索引 Index<br>Index 的 Key 是索引值，值是具有该索引值的资源对象的 Key</p><h2 id="KeyFunc-与-IndexFunc"><a href="#KeyFunc-与-IndexFunc" class="headerlink" title="KeyFunc 与 IndexFunc"></a>KeyFunc 与 IndexFunc</h2><p>KeyFunc 与 IndexFunc 对比如下：</p><ul><li>KeyFunc: f(obj) -&gt; key</li><li>IndexFunc: f(obj) -&gt; indexValue1, indexValue2 …</li></ul><p>由上对比可知 KeyFunc 是 IndexFunc 的一个特例，当 IndexFunc 只返回一个索引值时它就退化为 KeyFunc，client-go 中也提供了由 IndexFunc 到 KeyFunc 的适配函数：</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IndexFuncToKeyFuncAdapter</span><span class="hljs-params">(indexFunc IndexFunc)</span> <span class="hljs-title">KeyFunc</span></span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, error)</span></span> &#123;        indexKeys, err := indexFunc(obj)        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err        &#125;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(indexKeys) &gt; <span class="hljs-number">1</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, fmt.Errorf(<span class="hljs-string">&quot;too many keys: %v&quot;</span>, indexKeys)        &#125;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(indexKeys) == <span class="hljs-number">0</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, fmt.Errorf(<span class="hljs-string">&quot;unexpected empty indexKeys&quot;</span>)        &#125;        <span class="hljs-keyword">return</span> indexKeys[<span class="hljs-number">0</span>], <span class="hljs-literal">nil</span>    &#125;&#125;</code></pre><p>常用的 KeyFunc 有 <code>MetaNamespaceKeyFunc</code>, 即 f(obj) -&gt; namespace/name<br>常用的 IndexFunc 则有 <code>MetaNamespaceIndexFunc</code>, 即 f(obj) -&gt; [namespace]</p><h2 id="threadSafeMap"><a href="#threadSafeMap" class="headerlink" title="threadSafeMap"></a>threadSafeMap</h2><p><code>threadSafeMap</code> 是 <code>ThreadSafeStore</code> 的具体实现，通过 <code>sync.RWMutex</code> 实现线程安全。threadSafeMap 只能保证其定义的操作是线程安全的，直接对 Get/List 等操作返回的结果进行修改是无法保证的。</p><p>threadSafeMap 的数据结构如下，它的增删查改操作主要就是操作 <code>items</code>，同时通过 indexers 计算资源对象在各个索引中的值，通过  <code>updateIndices</code> 和 <code>deleteFromIndices</code> 对 <code>indices</code> 进行更新。</p><pre><code class="hljs Go"><span class="hljs-keyword">type</span> threadSafeMap <span class="hljs-keyword">struct</span> &#123;    lock  sync.RWMutex    items <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;    <span class="hljs-comment">// indexers maps a name to an IndexFunc</span>    indexers Indexers    <span class="hljs-comment">// indices maps a name to an Index</span>    indices Indices&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>源码</tag>
      
      <tag>client-go</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
