<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Kubernetes 源码阅读 -- Indexer</title>
    <link href="/2020/10/22/Kubernetes-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-Indexer/"/>
    <url>/2020/10/22/Kubernetes-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-Indexer/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://github.com/kubernetes/client-go/blob/d1a4fe5f2d96df815903781843870155cb4f5f40/tools/cache/index.go#L35"><code>Indexer</code></a> 是 kubernetes 中用于在内存中缓存资源对象的接口，支持通过 Key 对存储的资源对象进行增、删、查、改操作， 同时也可以对存储的对象进行倒排索引。</p><p><code>cache</code> 是 <code>Indexer</code> 的实现方式，其定义如下：</p><pre><code class="hljs Go"><span class="hljs-keyword">type</span> cache <span class="hljs-keyword">struct</span> &#123;    cacheStorage    ThreadSafeStore    keyFunc         KeyFunc&#125;</code></pre><p><code>ThreadSafeStore</code> 定义了一个线程安全的存储接口，由 <code>threadSafeMap</code> 实现。</p><p>ThreadSafeStore 与 Indexer 非常相似，前者可以看作是后者的一种特例。ThreadSafeStore 操作资源对象时需要指定对象的 key，而 Indexer 则不需要，是在 Indexer 的实现结构 cache 中通过 <code>keyFunc</code> 动态计算资源对象的 key。因此可以认为 <code>Indexer = ThreadSafeStore + KeyFunc</code>。</p><h2 id="Indexer"><a href="#Indexer" class="headerlink" title="Indexer"></a>Indexer</h2><p>Indexer 与其它数据结构的关系如下：<br><img src="http://lc-c7oxru7u.cn-n1.lcfile.com/c34bc3865ff4230a648a.png/diagram-16025179975213868166.png" alt="Indexer UML"></p><p>从图中可以看出没有索引的 cache 就是一个 Store，源码中 Indexer 和 Store 的创建方式分别如下：</p><pre><code class="hljs GO"><span class="hljs-comment">// NewStore returns a Store implemented simply with a map and a lock.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewStore</span><span class="hljs-params">(keyFunc KeyFunc)</span> <span class="hljs-title">Store</span></span> &#123;    <span class="hljs-keyword">return</span> &amp;cache&#123;        cacheStorage: NewThreadSafeStore(Indexers&#123;&#125;, Indices&#123;&#125;),        keyFunc:      keyFunc,    &#125;&#125;<span class="hljs-comment">// NewIndexer returns an Indexer implemented simply with a map and a lock.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewIndexer</span><span class="hljs-params">(keyFunc KeyFunc, indexers Indexers)</span> <span class="hljs-title">Indexer</span></span> &#123;    <span class="hljs-keyword">return</span> &amp;cache&#123;        cacheStorage: NewThreadSafeStore(indexers, Indices&#123;&#125;),        keyFunc:      keyFunc,    &#125;<span class="hljs-keyword">type</span> KeyFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, error)</span></span></code></pre><p><code>ThreadSafeStore</code> 通过 <code>indexers</code> 创建索引，indexers 是一个如下的 map：</p><pre><code class="hljs GO"><span class="hljs-keyword">type</span> Indexers <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]IndexFunc<span class="hljs-keyword">type</span> IndexFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">([]<span class="hljs-keyword">string</span>, error)</span></span></code></pre><p>Indexers 的 Key 是索引名称，值是 <em>根据资源对象创建计算该索引的索引值的函数</em></p><p><code>Indices</code> 是存储倒排索引的数据结构：</p><pre><code class="hljs Go"><span class="hljs-keyword">type</span> Indices <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]Index<span class="hljs-keyword">type</span> Index <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]sets.String</code></pre><p>Indices 的 Key 是索引名, 值是对应的索引 Index<br>Index 的 Key 是索引值，值是具有该索引值的资源对象的 Key</p><h2 id="KeyFunc-与-IndexFunc"><a href="#KeyFunc-与-IndexFunc" class="headerlink" title="KeyFunc 与 IndexFunc"></a>KeyFunc 与 IndexFunc</h2><p>KeyFunc 与 IndexFunc 对比如下：</p><ul><li>KeyFunc: f(obj) -&gt; key</li><li>IndexFunc: f(obj) -&gt; indexValue1, indexValue2 …</li></ul><p>由上对比可知 KeyFunc 是 IndexFunc 的一个特例，当 IndexFunc 只返回一个索引值时它就退化为 KeyFunc，client-go 中也提供了由 IndexFunc 到 KeyFunc 的适配函数：</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IndexFuncToKeyFuncAdapter</span><span class="hljs-params">(indexFunc IndexFunc)</span> <span class="hljs-title">KeyFunc</span></span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, error)</span></span> &#123;        indexKeys, err := indexFunc(obj)        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err        &#125;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(indexKeys) &gt; <span class="hljs-number">1</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, fmt.Errorf(<span class="hljs-string">&quot;too many keys: %v&quot;</span>, indexKeys)        &#125;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(indexKeys) == <span class="hljs-number">0</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, fmt.Errorf(<span class="hljs-string">&quot;unexpected empty indexKeys&quot;</span>)        &#125;        <span class="hljs-keyword">return</span> indexKeys[<span class="hljs-number">0</span>], <span class="hljs-literal">nil</span>    &#125;&#125;</code></pre><p>常用的 KeyFunc 有 <code>MetaNamespaceKeyFunc</code>, 即 f(obj) -&gt; namespace/name<br>常用的 IndexFunc 则有 <code>MetaNamespaceIndexFunc</code>, 即 f(obj) -&gt; [namespace]</p><h2 id="threadSafeMap"><a href="#threadSafeMap" class="headerlink" title="threadSafeMap"></a>threadSafeMap</h2><p><code>threadSafeMap</code> 是 <code>ThreadSafeStore</code> 的具体实现，通过 <code>sync.RWMutex</code> 实现线程安全。threadSafeMap 只能保证其定义的操作是线程安全的，直接对 Get/List 等操作返回的结果进行修改是无法保证的。</p><p>threadSafeMap 的数据结构如下，它的增删查改操作主要就是操作 <code>items</code>，同时通过 indexers 计算资源对象在各个索引中的值，通过  <code>updateIndices</code> 和 <code>deleteFromIndices</code> 对 <code>indices</code> 进行更新。</p><pre><code class="hljs Go"><span class="hljs-keyword">type</span> threadSafeMap <span class="hljs-keyword">struct</span> &#123;    lock  sync.RWMutex    items <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;    <span class="hljs-comment">// indexers maps a name to an IndexFunc</span>    indexers Indexers    <span class="hljs-comment">// indices maps a name to an Index</span>    indices Indices&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>源码</tag>
      
      <tag>client-go</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
