{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/clipboard-use.js","path":"js/clipboard-use.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/debouncer.js","path":"js/debouncer.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/lazyload.js","path":"js/lazyload.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/hint/hint.min.css","path":"lib/hint/hint.min.css","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1601996137900},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"5b919c12e4f5f5cdebb7c17ded4f10f1ebe64811","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"557aef4c09566a4d09e33c0575ea2fb44786e179","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/README_en.md","hash":"afdfabc2763baa03ceda722c0a05e0f6680166f7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/_static_prefix.yml","hash":"d5eb27044090c50bdee4ffcf738662ce469c870a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/gulpfile.js","hash":"dc82b6be72c786721a2f5e2acc10a2a94995c540","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"8208e970e1f2267a4204b4e2aec0c458b8286395","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"f049d2e2da7e0415592371f985e3c7ae13a66ee0","modified":1601999568840},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"e967e102bab2b35b9083165c2b8e037db8e0a32d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"094357be1c2c6b477269a3f4b725d3c5dd24ef8c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"6c4ab9fcdf5f7b58238bf06276b027075872c424","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"1cfe94f46f1492a411d431b02a8d09c99cab77d5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"9534043275df504d70232c07fec7e10503b85d32","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"49a7f26815a25bbc2ed0ed78a966406f5d8c1c5e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"6abd180ff4dd1d5d22e4c70328e3c7f83d174d9c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"8cab50ead4cdb992d35710147a9a5308fb5df290","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"59551ef5d9c0dee8c162ac39a18a96dafe5e1358","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"fd72ec9e6629facf63ce8122f0fa8d492669fa6a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"8f20dca8a03aefd495d0550544f25d8c6e44333e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"5c5a5565bb13928bc92332d9b99b968673ea7dfb","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"d3a3204d9bb2b43a69c9cb0be59bada8cb91e412","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"a413dc14e4737dbcaa8fb797d37f85121ede6551","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/lint.yaml","hash":"628f8d7655fdba149f5a9b0232df5c3225eda9da","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/beian.ejs","hash":"4f3acc8dc822c85d0d778552a15875f71c0cd80a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/css.ejs","hash":"44d7248fb15361fd23b774f0816c6480b8fdc52e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/footer.ejs","hash":"03defcd4409dce27447aa8dfe7ce41a2d47e373b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/head.ejs","hash":"55f62c4766f5d505e8307e667f83ea459b84dfb6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/nav.ejs","hash":"70490c67b7313ae305d39331238232fe62f094f1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/paginator.ejs","hash":"783eee847562ce14db8f723b4ae742fb69aaf620","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/post-meta.ejs","hash":"7c40672443ba61b62b68a9aa6685ea944dbbb061","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/scripts.ejs","hash":"9f9e40a348771463cc70d6592198604ca49fc050","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/toc.ejs","hash":"3cf1d9b9032919d6b936e1f2410911df3b325670","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"a6ab2c6d9f9ba58cd1fabb85c2817874246fd525","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"6665f19fa30cbbe0853d8140a0832f8638538f89","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"01439b3d7abdeb5e51f810d784181c1d420be55d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"d45dce23532c17367c7eb86b94afa8c9e40d16c6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"99ab4551dc9c035abcc3bf4da5def2f63449d7ec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"9045f47c7a71aab39f16cffb3e3847b752c2e0f1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"e58d422eddb44c1be893f65f79f4c7feecfe6d5f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"63468f7875c09d9557fe8315afc97175745d9087","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"0886cfe3f8589671a1d289495e359c20a9908080","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/join-path.js","hash":"629e7deb3955f750c1cfa6fc773f412e020fcef4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"61e9555f99edcb23d55361c7154e23af33153ecb","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","hash":"cd06ec95988bc0287d444fc98d4a6d2cc576ace4","modified":1602001657244},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/clipboard-use.js","hash":"f0ffe3df1deeb3cc36adfee2ab839368fb28d1c9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"03d5315b752cd3e13749cca790783a1e1cfab0a8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/debouncer.js","hash":"045f324777bdfb99d4c17b1806169f029f897a65","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/lazyload.js","hash":"792deca48c12512d3e612f0de092ffcff3ca3e34","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"13d5ef2fe68c49bd6096781034dbb26c190b5176","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"9b06e2e2a2bb92e27d15a700f28f880317c25cfa","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/main.js","hash":"a6def6368d288892088f78fd401e7170e3e81a13","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/changyan.ejs","hash":"13c0b62854668fd83287dff3792997baeeb3a2c7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/disqus.ejs","hash":"eeb3462cbedd195156aa671fb522bebee0274b5e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/gitalk.ejs","hash":"096fef408349db4ebbec84cf20a373dd46c8f4ff","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/remark42.ejs","hash":"3c254c1b7bc5a4c6bd5b724514d463608408018b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/livere.ejs","hash":"f1e5d89cc98e2f6e067e5cd3db728127ccff0105","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/utterances.ejs","hash":"2b9a49594e9aea4dc8fdd606a63c8c5b9189e325","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/valine.ejs","hash":"37941b3c6f66f1f22aeff734802373657dfdfb99","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/analytics.ejs","hash":"557077a8825fffc0a2c7fe2b29f319287950244f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/aplayer.ejs","hash":"e843cdbe64af3dee9385eb1d763539d3ac10ed72","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/anchor.ejs","hash":"3738c2ef427b4b400225b92e638a17b7ab2125ed","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/daovoice.ejs","hash":"cfc684ba48608abd25afd155ee373d9936bbe84e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/fancybox.ejs","hash":"c447e35c93c61a70c1c2dfc34948615832989660","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/leancloud.ejs","hash":"7807e58722dcf992fba11bc879b0fac0e904dc76","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/local-search.ejs","hash":"03b024c7bab51b64e5187c9dbfac039d020f1e97","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/math.ejs","hash":"76c4e0608ae362a265ac5e9c0fc49f75c1bc568e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/tocjs.ejs","hash":"2d35295dba2bb912d6ce2ec7747af06bfdc82edb","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/mouse-click.ejs","hash":"eb19991199c201ceb103a6ef025e4dfd1e7dbfb7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/typed.ejs","hash":"38334350425008d1f64323de221457ee0948af0e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"da4c281a8b2d2ed813da1236950c9dff87334adc","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"96d56372cad997b09c26dbd29a19f917140c6ab0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"ee7dfef805af96195c11223cca53983deace8bda","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"a25a40036ef38c8dc92574079007882a0d75338a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/preset-configs.js","hash":"202459c9444b1ba967396db3625af261b0b19820","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/version.js","hash":"0250fb16c7c798afd1f7fc816163ea0728765568","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"fe96204aa2e7ee4f7f404c9e90752a8ff822d779","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"15d2786d00418e61022475194ad76445d68e27ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"aa2528e71c290dc43b69dfbdcf4d8d6c258015a4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"f7004d597163e0af7b9107b0be1df12f4c0a7bc0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"fab8441a0b8d8f9db6c8370013659c035345ae79","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/rewrite.styl","hash":"4f939807936632f2ff2504f139648033aa351957","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"c443551deb389102e65cbb2441f60e8c20712ee8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"cd4ebb1426abed9fda93b797b02c6d5dd71dc2a1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post.styl","hash":"1e7e4290a7653f748e0a46c81cc6aed4564f8bf4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/tag_plugin.styl","hash":"cbb49a17fcc030029f0c2fbe1e056613109d1ecc","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"ec4e9678d2f4df03b1ad773adf57acc83a947687","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"2c9e05a354d4be820646a1c99f814740f299ed37","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"6b8340a41afc6b6e5f30dc9e912a0e0265446963","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"7c8170d0e2de47570fe8ed523f10ee1c33138a9f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"fe74d031acef4403e1510d4cce5bc7accd641780","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"e4ad804ab26bdbf5b55abbc5548b6db395cfed04","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":499162500000},{"_id":"source/about/index.md","hash":"d1862679b4e3a6316f40cc05510ff9c609cda47b","modified":1601999904005},{"_id":"themes/fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1599451061000},{"_id":"themes/fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1599451061000},{"_id":"themes/fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1599451061000},{"_id":"themes/fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1599451061000},{"_id":"themes/fluid/.gitignore","hash":"bd095eee271360a38772ee1a42d4f000fb722e5f","modified":1599451061000},{"_id":"themes/fluid/LICENSE","hash":"5b919c12e4f5f5cdebb7c17ded4f10f1ebe64811","modified":1599451061000},{"_id":"themes/fluid/README.md","hash":"557aef4c09566a4d09e33c0575ea2fb44786e179","modified":1599451061000},{"_id":"themes/fluid/README_en.md","hash":"afdfabc2763baa03ceda722c0a05e0f6680166f7","modified":1599451061000},{"_id":"themes/fluid/_config.yml","hash":"8208e970e1f2267a4204b4e2aec0c458b8286395","modified":1599451061000},{"_id":"themes/fluid/_static_prefix.yml","hash":"d5eb27044090c50bdee4ffcf738662ce469c870a","modified":1599451061000},{"_id":"themes/fluid/gulpfile.js","hash":"dc82b6be72c786721a2f5e2acc10a2a94995c540","modified":1599451061000},{"_id":"themes/fluid/package.json","hash":"2390818b24d2f525bfca6cbc7f55e6650a513f3d","modified":1599451061000},{"_id":"themes/fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":1599451061000},{"_id":"themes/fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":1599451061000},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":1599451061000},{"_id":"themes/fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":1599451061000},{"_id":"themes/fluid/layout/about.ejs","hash":"e967e102bab2b35b9083165c2b8e037db8e0a32d","modified":1599451061000},{"_id":"themes/fluid/layout/archive.ejs","hash":"094357be1c2c6b477269a3f4b725d3c5dd24ef8c","modified":1599451061000},{"_id":"themes/fluid/layout/categories.ejs","hash":"6c4ab9fcdf5f7b58238bf06276b027075872c424","modified":1599451061000},{"_id":"themes/fluid/layout/category.ejs","hash":"1cfe94f46f1492a411d431b02a8d09c99cab77d5","modified":1599451061000},{"_id":"themes/fluid/layout/index.ejs","hash":"9534043275df504d70232c07fec7e10503b85d32","modified":1599451061000},{"_id":"themes/fluid/layout/layout.ejs","hash":"49a7f26815a25bbc2ed0ed78a966406f5d8c1c5e","modified":1599451061000},{"_id":"themes/fluid/layout/links.ejs","hash":"6abd180ff4dd1d5d22e4c70328e3c7f83d174d9c","modified":1599451061000},{"_id":"themes/fluid/layout/page.ejs","hash":"8cab50ead4cdb992d35710147a9a5308fb5df290","modified":1599451061000},{"_id":"themes/fluid/layout/post.ejs","hash":"59551ef5d9c0dee8c162ac39a18a96dafe5e1358","modified":1599451061000},{"_id":"themes/fluid/layout/tag.ejs","hash":"fd72ec9e6629facf63ce8122f0fa8d492669fa6a","modified":1599451061000},{"_id":"themes/fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1599451061000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"8f20dca8a03aefd495d0550544f25d8c6e44333e","modified":1599451061000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"5c5a5565bb13928bc92332d9b99b968673ea7dfb","modified":1599451061000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"d3a3204d9bb2b43a69c9cb0be59bada8cb91e412","modified":1599451061000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"a413dc14e4737dbcaa8fb797d37f85121ede6551","modified":1599451061000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":1599451061000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":1599451061000},{"_id":"themes/fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1599451061000},{"_id":"themes/fluid/.github/workflows/lint.yaml","hash":"628f8d7655fdba149f5a9b0232df5c3225eda9da","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/beian.ejs","hash":"4f3acc8dc822c85d0d778552a15875f71c0cd80a","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/css.ejs","hash":"44d7248fb15361fd23b774f0816c6480b8fdc52e","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/footer.ejs","hash":"03defcd4409dce27447aa8dfe7ce41a2d47e373b","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/head.ejs","hash":"55f62c4766f5d505e8307e667f83ea459b84dfb6","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/nav.ejs","hash":"70490c67b7313ae305d39331238232fe62f094f1","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/paginator.ejs","hash":"783eee847562ce14db8f723b4ae742fb69aaf620","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/post-meta.ejs","hash":"7c40672443ba61b62b68a9aa6685ea944dbbb061","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/scripts.ejs","hash":"9f9e40a348771463cc70d6592198604ca49fc050","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/toc.ejs","hash":"3cf1d9b9032919d6b936e1f2410911df3b325670","modified":1599451061000},{"_id":"themes/fluid/scripts/events/index.js","hash":"a6ab2c6d9f9ba58cd1fabb85c2817874246fd525","modified":1599451061000},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"6665f19fa30cbbe0853d8140a0832f8638538f89","modified":1599451061000},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1599451061000},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"01439b3d7abdeb5e51f810d784181c1d420be55d","modified":1599451061000},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"d45dce23532c17367c7eb86b94afa8c9e40d16c6","modified":1599451061000},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"99ab4551dc9c035abcc3bf4da5def2f63449d7ec","modified":1599451061000},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"9045f47c7a71aab39f16cffb3e3847b752c2e0f1","modified":1599451061000},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"e58d422eddb44c1be893f65f79f4c7feecfe6d5f","modified":1599451061000},{"_id":"themes/fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1599451061000},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"63468f7875c09d9557fe8315afc97175745d9087","modified":1599451061000},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1599451061000},{"_id":"themes/fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1599451061000},{"_id":"themes/fluid/scripts/tags/note.js","hash":"0886cfe3f8589671a1d289495e359c20a9908080","modified":1599451061000},{"_id":"themes/fluid/scripts/utils/join-path.js","hash":"629e7deb3955f750c1cfa6fc773f412e020fcef4","modified":1599451061000},{"_id":"themes/fluid/scripts/utils/object.js","hash":"61e9555f99edcb23d55361c7154e23af33153ecb","modified":1599451061000},{"_id":"themes/fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":1599451061000},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1599451061000},{"_id":"themes/fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1599451061000},{"_id":"themes/fluid/source/img/favicon.png","hash":"cd06ec95988bc0287d444fc98d4a6d2cc576ace4","modified":1602007038894},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1599451061000},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1599451061000},{"_id":"themes/fluid/source/js/clipboard-use.js","hash":"f0ffe3df1deeb3cc36adfee2ab839368fb28d1c9","modified":1599451061000},{"_id":"themes/fluid/source/js/color-schema.js","hash":"03d5315b752cd3e13749cca790783a1e1cfab0a8","modified":1599451061000},{"_id":"themes/fluid/source/js/debouncer.js","hash":"045f324777bdfb99d4c17b1806169f029f897a65","modified":1599451061000},{"_id":"themes/fluid/source/js/lazyload.js","hash":"792deca48c12512d3e612f0de092ffcff3ca3e34","modified":1599451061000},{"_id":"themes/fluid/source/js/local-search.js","hash":"13d5ef2fe68c49bd6096781034dbb26c190b5176","modified":1599451061000},{"_id":"themes/fluid/source/js/main.js","hash":"a6def6368d288892088f78fd401e7170e3e81a13","modified":1599451061000},{"_id":"themes/fluid/source/js/utils.js","hash":"9b06e2e2a2bb92e27d15a700f28f880317c25cfa","modified":1599451061000},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/comments/changyan.ejs","hash":"13c0b62854668fd83287dff3792997baeeb3a2c7","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/comments/disqus.ejs","hash":"eeb3462cbedd195156aa671fb522bebee0274b5e","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/comments/gitalk.ejs","hash":"096fef408349db4ebbec84cf20a373dd46c8f4ff","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/comments/livere.ejs","hash":"f1e5d89cc98e2f6e067e5cd3db728127ccff0105","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/comments/remark42.ejs","hash":"3c254c1b7bc5a4c6bd5b724514d463608408018b","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/comments/utterances.ejs","hash":"2b9a49594e9aea4dc8fdd606a63c8c5b9189e325","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/comments/valine.ejs","hash":"37941b3c6f66f1f22aeff734802373657dfdfb99","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/plugins/analytics.ejs","hash":"557077a8825fffc0a2c7fe2b29f319287950244f","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/plugins/anchor.ejs","hash":"3738c2ef427b4b400225b92e638a17b7ab2125ed","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/plugins/aplayer.ejs","hash":"e843cdbe64af3dee9385eb1d763539d3ac10ed72","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/plugins/daovoice.ejs","hash":"cfc684ba48608abd25afd155ee373d9936bbe84e","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/plugins/fancybox.ejs","hash":"c447e35c93c61a70c1c2dfc34948615832989660","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/plugins/leancloud.ejs","hash":"7807e58722dcf992fba11bc879b0fac0e904dc76","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/plugins/local-search.ejs","hash":"03b024c7bab51b64e5187c9dbfac039d020f1e97","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/plugins/math.ejs","hash":"76c4e0608ae362a265ac5e9c0fc49f75c1bc568e","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/plugins/mouse-click.ejs","hash":"eb19991199c201ceb103a6ef025e4dfd1e7dbfb7","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/plugins/tocjs.ejs","hash":"2d35295dba2bb912d6ce2ec7747af06bfdc82edb","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/plugins/typed.ejs","hash":"38334350425008d1f64323de221457ee0948af0e","modified":1599451061000},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":1599451061000},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"da4c281a8b2d2ed813da1236950c9dff87334adc","modified":1599451061000},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"96d56372cad997b09c26dbd29a19f917140c6ab0","modified":1599451061000},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"ee7dfef805af96195c11223cca53983deace8bda","modified":1599451061000},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"a25a40036ef38c8dc92574079007882a0d75338a","modified":1599451061000},{"_id":"themes/fluid/scripts/events/lib/preset-configs.js","hash":"202459c9444b1ba967396db3625af261b0b19820","modified":1599451061000},{"_id":"themes/fluid/scripts/events/lib/version.js","hash":"0250fb16c7c798afd1f7fc816163ea0728765568","modified":1599451061000},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1599451061000},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1599451061000},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"fe96204aa2e7ee4f7f404c9e90752a8ff822d779","modified":1599451061000},{"_id":"themes/fluid/source/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"15d2786d00418e61022475194ad76445d68e27ea","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"aa2528e71c290dc43b69dfbdcf4d8d6c258015a4","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"f7004d597163e0af7b9107b0be1df12f4c0a7bc0","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"fab8441a0b8d8f9db6c8370013659c035345ae79","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/rewrite.styl","hash":"4f939807936632f2ff2504f139648033aa351957","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"c443551deb389102e65cbb2441f60e8c20712ee8","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"cd4ebb1426abed9fda93b797b02c6d5dd71dc2a1","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_post/post.styl","hash":"1e7e4290a7653f748e0a46c81cc6aed4564f8bf4","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_post/tag_plugin.styl","hash":"cbb49a17fcc030029f0c2fbe1e056613109d1ecc","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"ec4e9678d2f4df03b1ad773adf57acc83a947687","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"2c9e05a354d4be820646a1c99f814740f299ed37","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"6b8340a41afc6b6e5f30dc9e912a0e0265446963","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"7c8170d0e2de47570fe8ed523f10ee1c33138a9f","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"fe74d031acef4403e1510d4cce5bc7accd641780","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"e4ad804ab26bdbf5b55abbc5548b6db395cfed04","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1599451061000},{"_id":"source/_posts/Kubernetes-源码阅读-Indexer.md","hash":"49d4349774c9499862cede9398b50019539b416c","modified":1603385405248},{"_id":"source/_posts/Kubernetes-源码阅读-Expiring.md","hash":"318c781b1ea03b2f87b4ccca7687f4756f5038fd","modified":1609602417823},{"_id":"source/CNAME","hash":"27d9ca69399b9988b566e821b6dcb3b3d6c5e6b2","modified":1603385738195},{"_id":"source/_posts/go-标准库源码-heap.md","hash":"a7d26f9dd3c967c1070bdce134f9eb9a324f8c9a","modified":1612108599998},{"_id":"source/_posts/sync-Map-源码阅读.md","hash":"c34e13ae8430e405e153961eb3182c0e8c98f034","modified":1611850359364},{"_id":"source/_posts/sync-Once中的快速路径.md","hash":"e9fa5ff2dc11891b5ddcc14dbf66419f31dce69e","modified":1611506460091}],"Category":[{"name":"kubernetes","_id":"ckgkztjux0001uffy77h0ep4s"},{"name":"golang","_id":"ckklbag4y0002z5fy7woreo2h"}],"Data":[],"Page":[{"title":"about","date":"2020-10-06T15:58:23.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-10-06 23:58:23\n---\n","updated":"2020-10-06T15:58:24.005Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckfy5ebqc0000lvys5b1d8en5","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Kubernetes 源码阅读 -- Indexer","date":"2020-10-22T15:36:37.000Z","_content":"\n## 概述\n\n[`Indexer`](https://github.com/kubernetes/client-go/blob/d1a4fe5f2d96df815903781843870155cb4f5f40/tools/cache/index.go#L35) 是 kubernetes 中用于在内存中缓存资源对象的接口，支持通过 Key 对存储的资源对象进行增、删、查、改操作， 同时也可以对存储的对象进行倒排索引。\n\n`cache` 是 `Indexer` 的实现方式，其定义如下：\n\n``` Go\ntype cache struct {\n    cacheStorage    ThreadSafeStore\n    keyFunc         KeyFunc\n}\n```\n\n`ThreadSafeStore` 定义了一个线程安全的存储接口，由 `threadSafeMap` 实现。\n\nThreadSafeStore 与 Indexer 非常相似，前者可以看作是后者的一种特例。ThreadSafeStore 操作资源对象时需要指定对象的 key，而 Indexer 则不需要，是在 Indexer 的实现结构 cache 中通过 `keyFunc` 动态计算资源对象的 key。因此可以认为 `Indexer = ThreadSafeStore + KeyFunc`。\n\n## Indexer\n\nIndexer 与其它数据结构的关系如下：\n![Indexer UML](http://lc-C7OxrU7U.cn-n1.lcfile.com/c34bc3865ff4230a648a.png/diagram-16025179975213868166.png)\n\n从图中可以看出没有索引的 cache 就是一个 Store，源码中 Indexer 和 Store 的创建方式分别如下：\n\n```GO\n// NewStore returns a Store implemented simply with a map and a lock.\nfunc NewStore(keyFunc KeyFunc) Store {\n    return &cache{\n        cacheStorage: NewThreadSafeStore(Indexers{}, Indices{}),\n        keyFunc:      keyFunc,\n    }\n}\n\n// NewIndexer returns an Indexer implemented simply with a map and a lock.\nfunc NewIndexer(keyFunc KeyFunc, indexers Indexers) Indexer {\n    return &cache{\n        cacheStorage: NewThreadSafeStore(indexers, Indices{}),\n        keyFunc:      keyFunc,\n    }\n\ntype KeyFunc func(obj interface{}) (string, error)\n```\n\n`ThreadSafeStore` 通过 `indexers` 创建索引，indexers 是一个如下的 map：\n\n```GO\ntype Indexers map[string]IndexFunc\n\ntype IndexFunc func(obj interface{}) ([]string, error)\n```\n\nIndexers 的 Key 是索引名称，值是 _根据资源对象创建计算该索引的索引值的函数_\n\n`Indices` 是存储倒排索引的数据结构：\n\n```Go\ntype Indices map[string]Index\n\ntype Index map[string]sets.String\n```\n\nIndices 的 Key 是索引名, 值是对应的索引 Index\nIndex 的 Key 是索引值，值是具有该索引值的资源对象的 Key\n\n## KeyFunc 与 IndexFunc\n\nKeyFunc 与 IndexFunc 对比如下：\n\n- KeyFunc: f(obj) -> key\n- IndexFunc: f(obj) -> indexValue1, indexValue2 ...\n\n由上对比可知 KeyFunc 是 IndexFunc 的一个特例，当 IndexFunc 只返回一个索引值时它就退化为 KeyFunc，client-go 中也提供了由 IndexFunc 到 KeyFunc 的适配函数：\n\n```Go\nfunc IndexFuncToKeyFuncAdapter(indexFunc IndexFunc) KeyFunc {\n    return func(obj interface{}) (string, error) {\n        indexKeys, err := indexFunc(obj)\n        if err != nil {\n            return \"\", err\n        }\n        if len(indexKeys) > 1 {\n            return \"\", fmt.Errorf(\"too many keys: %v\", indexKeys)\n        }\n        if len(indexKeys) == 0 {\n            return \"\", fmt.Errorf(\"unexpected empty indexKeys\")\n        }\n        return indexKeys[0], nil\n    }\n}\n```\n\n常用的 KeyFunc 有 `MetaNamespaceKeyFunc`, 即 f(obj) -> namespace/name\n常用的 IndexFunc 则有 `MetaNamespaceIndexFunc`, 即 f(obj) -> [namespace]\n\n## threadSafeMap\n\n`threadSafeMap` 是 `ThreadSafeStore` 的具体实现，通过 `sync.RWMutex` 实现线程安全。threadSafeMap 只能保证其定义的操作是线程安全的，直接对 Get/List 等操作返回的结果进行修改是无法保证的。\n\nthreadSafeMap 的数据结构如下，它的增删查改操作主要就是操作 `items`，同时通过 indexers 计算资源对象在各个索引中的值，通过  `updateIndices` 和 `deleteFromIndices` 对 `indices` 进行更新。\n\n```Go\ntype threadSafeMap struct {\n    lock  sync.RWMutex\n    items map[string]interface{}\n\n    // indexers maps a name to an IndexFunc\n    indexers Indexers\n    // indices maps a name to an Index\n    indices Indices\n}\n```\n","source":"_posts/Kubernetes-源码阅读-Indexer.md","raw":"---\ntitle: Kubernetes 源码阅读 -- Indexer\ndate: 2020-10-22 23:36:37\ntags: [k8s, 源码, client-go]\ncategories: kubernetes\n---\n\n## 概述\n\n[`Indexer`](https://github.com/kubernetes/client-go/blob/d1a4fe5f2d96df815903781843870155cb4f5f40/tools/cache/index.go#L35) 是 kubernetes 中用于在内存中缓存资源对象的接口，支持通过 Key 对存储的资源对象进行增、删、查、改操作， 同时也可以对存储的对象进行倒排索引。\n\n`cache` 是 `Indexer` 的实现方式，其定义如下：\n\n``` Go\ntype cache struct {\n    cacheStorage    ThreadSafeStore\n    keyFunc         KeyFunc\n}\n```\n\n`ThreadSafeStore` 定义了一个线程安全的存储接口，由 `threadSafeMap` 实现。\n\nThreadSafeStore 与 Indexer 非常相似，前者可以看作是后者的一种特例。ThreadSafeStore 操作资源对象时需要指定对象的 key，而 Indexer 则不需要，是在 Indexer 的实现结构 cache 中通过 `keyFunc` 动态计算资源对象的 key。因此可以认为 `Indexer = ThreadSafeStore + KeyFunc`。\n\n## Indexer\n\nIndexer 与其它数据结构的关系如下：\n![Indexer UML](http://lc-C7OxrU7U.cn-n1.lcfile.com/c34bc3865ff4230a648a.png/diagram-16025179975213868166.png)\n\n从图中可以看出没有索引的 cache 就是一个 Store，源码中 Indexer 和 Store 的创建方式分别如下：\n\n```GO\n// NewStore returns a Store implemented simply with a map and a lock.\nfunc NewStore(keyFunc KeyFunc) Store {\n    return &cache{\n        cacheStorage: NewThreadSafeStore(Indexers{}, Indices{}),\n        keyFunc:      keyFunc,\n    }\n}\n\n// NewIndexer returns an Indexer implemented simply with a map and a lock.\nfunc NewIndexer(keyFunc KeyFunc, indexers Indexers) Indexer {\n    return &cache{\n        cacheStorage: NewThreadSafeStore(indexers, Indices{}),\n        keyFunc:      keyFunc,\n    }\n\ntype KeyFunc func(obj interface{}) (string, error)\n```\n\n`ThreadSafeStore` 通过 `indexers` 创建索引，indexers 是一个如下的 map：\n\n```GO\ntype Indexers map[string]IndexFunc\n\ntype IndexFunc func(obj interface{}) ([]string, error)\n```\n\nIndexers 的 Key 是索引名称，值是 _根据资源对象创建计算该索引的索引值的函数_\n\n`Indices` 是存储倒排索引的数据结构：\n\n```Go\ntype Indices map[string]Index\n\ntype Index map[string]sets.String\n```\n\nIndices 的 Key 是索引名, 值是对应的索引 Index\nIndex 的 Key 是索引值，值是具有该索引值的资源对象的 Key\n\n## KeyFunc 与 IndexFunc\n\nKeyFunc 与 IndexFunc 对比如下：\n\n- KeyFunc: f(obj) -> key\n- IndexFunc: f(obj) -> indexValue1, indexValue2 ...\n\n由上对比可知 KeyFunc 是 IndexFunc 的一个特例，当 IndexFunc 只返回一个索引值时它就退化为 KeyFunc，client-go 中也提供了由 IndexFunc 到 KeyFunc 的适配函数：\n\n```Go\nfunc IndexFuncToKeyFuncAdapter(indexFunc IndexFunc) KeyFunc {\n    return func(obj interface{}) (string, error) {\n        indexKeys, err := indexFunc(obj)\n        if err != nil {\n            return \"\", err\n        }\n        if len(indexKeys) > 1 {\n            return \"\", fmt.Errorf(\"too many keys: %v\", indexKeys)\n        }\n        if len(indexKeys) == 0 {\n            return \"\", fmt.Errorf(\"unexpected empty indexKeys\")\n        }\n        return indexKeys[0], nil\n    }\n}\n```\n\n常用的 KeyFunc 有 `MetaNamespaceKeyFunc`, 即 f(obj) -> namespace/name\n常用的 IndexFunc 则有 `MetaNamespaceIndexFunc`, 即 f(obj) -> [namespace]\n\n## threadSafeMap\n\n`threadSafeMap` 是 `ThreadSafeStore` 的具体实现，通过 `sync.RWMutex` 实现线程安全。threadSafeMap 只能保证其定义的操作是线程安全的，直接对 Get/List 等操作返回的结果进行修改是无法保证的。\n\nthreadSafeMap 的数据结构如下，它的增删查改操作主要就是操作 `items`，同时通过 indexers 计算资源对象在各个索引中的值，通过  `updateIndices` 和 `deleteFromIndices` 对 `indices` 进行更新。\n\n```Go\ntype threadSafeMap struct {\n    lock  sync.RWMutex\n    items map[string]interface{}\n\n    // indexers maps a name to an IndexFunc\n    indexers Indexers\n    // indices maps a name to an Index\n    indices Indices\n}\n```\n","slug":"Kubernetes-源码阅读-Indexer","published":1,"updated":"2020-10-22T16:50:05.248Z","_id":"ckgkztjut0000uffybu9e6o28","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><a href=\"https://github.com/kubernetes/client-go/blob/d1a4fe5f2d96df815903781843870155cb4f5f40/tools/cache/index.go#L35\"><code>Indexer</code></a> 是 kubernetes 中用于在内存中缓存资源对象的接口，支持通过 Key 对存储的资源对象进行增、删、查、改操作， 同时也可以对存储的对象进行倒排索引。</p>\n<p><code>cache</code> 是 <code>Indexer</code> 的实现方式，其定义如下：</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> cache <span class=\"hljs-keyword\">struct</span> &#123;\n    cacheStorage    ThreadSafeStore\n    keyFunc         KeyFunc\n&#125;</code></pre>\n\n<p><code>ThreadSafeStore</code> 定义了一个线程安全的存储接口，由 <code>threadSafeMap</code> 实现。</p>\n<p>ThreadSafeStore 与 Indexer 非常相似，前者可以看作是后者的一种特例。ThreadSafeStore 操作资源对象时需要指定对象的 key，而 Indexer 则不需要，是在 Indexer 的实现结构 cache 中通过 <code>keyFunc</code> 动态计算资源对象的 key。因此可以认为 <code>Indexer = ThreadSafeStore + KeyFunc</code>。</p>\n<h2 id=\"Indexer\"><a href=\"#Indexer\" class=\"headerlink\" title=\"Indexer\"></a>Indexer</h2><p>Indexer 与其它数据结构的关系如下：<br><img src=\"http://lc-c7oxru7u.cn-n1.lcfile.com/c34bc3865ff4230a648a.png/diagram-16025179975213868166.png\" alt=\"Indexer UML\"></p>\n<p>从图中可以看出没有索引的 cache 就是一个 Store，源码中 Indexer 和 Store 的创建方式分别如下：</p>\n<pre><code class=\"hljs GO\"><span class=\"hljs-comment\">// NewStore returns a Store implemented simply with a map and a lock.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">NewStore</span><span class=\"hljs-params\">(keyFunc KeyFunc)</span> <span class=\"hljs-title\">Store</span></span> &#123;\n    <span class=\"hljs-keyword\">return</span> &amp;cache&#123;\n        cacheStorage: NewThreadSafeStore(Indexers&#123;&#125;, Indices&#123;&#125;),\n        keyFunc:      keyFunc,\n    &#125;\n&#125;\n\n<span class=\"hljs-comment\">// NewIndexer returns an Indexer implemented simply with a map and a lock.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">NewIndexer</span><span class=\"hljs-params\">(keyFunc KeyFunc, indexers Indexers)</span> <span class=\"hljs-title\">Indexer</span></span> &#123;\n    <span class=\"hljs-keyword\">return</span> &amp;cache&#123;\n        cacheStorage: NewThreadSafeStore(indexers, Indices&#123;&#125;),\n        keyFunc:      keyFunc,\n    &#125;\n\n<span class=\"hljs-keyword\">type</span> KeyFunc <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(obj <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">string</span>, error)</span></span></code></pre>\n\n<p><code>ThreadSafeStore</code> 通过 <code>indexers</code> 创建索引，indexers 是一个如下的 map：</p>\n<pre><code class=\"hljs GO\"><span class=\"hljs-keyword\">type</span> Indexers <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]IndexFunc\n\n<span class=\"hljs-keyword\">type</span> IndexFunc <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(obj <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span> <span class=\"hljs-params\">([]<span class=\"hljs-keyword\">string</span>, error)</span></span></code></pre>\n\n<p>Indexers 的 Key 是索引名称，值是 <em>根据资源对象创建计算该索引的索引值的函数</em></p>\n<p><code>Indices</code> 是存储倒排索引的数据结构：</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> Indices <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]Index\n\n<span class=\"hljs-keyword\">type</span> Index <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]sets.String</code></pre>\n\n<p>Indices 的 Key 是索引名, 值是对应的索引 Index<br>Index 的 Key 是索引值，值是具有该索引值的资源对象的 Key</p>\n<h2 id=\"KeyFunc-与-IndexFunc\"><a href=\"#KeyFunc-与-IndexFunc\" class=\"headerlink\" title=\"KeyFunc 与 IndexFunc\"></a>KeyFunc 与 IndexFunc</h2><p>KeyFunc 与 IndexFunc 对比如下：</p>\n<ul>\n<li>KeyFunc: f(obj) -&gt; key</li>\n<li>IndexFunc: f(obj) -&gt; indexValue1, indexValue2 …</li>\n</ul>\n<p>由上对比可知 KeyFunc 是 IndexFunc 的一个特例，当 IndexFunc 只返回一个索引值时它就退化为 KeyFunc，client-go 中也提供了由 IndexFunc 到 KeyFunc 的适配函数：</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">IndexFuncToKeyFuncAdapter</span><span class=\"hljs-params\">(indexFunc IndexFunc)</span> <span class=\"hljs-title\">KeyFunc</span></span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(obj <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">string</span>, error)</span></span> &#123;\n        indexKeys, err := indexFunc(obj)\n        <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>, err\n        &#125;\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(indexKeys) &gt; <span class=\"hljs-number\">1</span> &#123;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>, fmt.Errorf(<span class=\"hljs-string\">&quot;too many keys: %v&quot;</span>, indexKeys)\n        &#125;\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(indexKeys) == <span class=\"hljs-number\">0</span> &#123;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>, fmt.Errorf(<span class=\"hljs-string\">&quot;unexpected empty indexKeys&quot;</span>)\n        &#125;\n        <span class=\"hljs-keyword\">return</span> indexKeys[<span class=\"hljs-number\">0</span>], <span class=\"hljs-literal\">nil</span>\n    &#125;\n&#125;</code></pre>\n\n<p>常用的 KeyFunc 有 <code>MetaNamespaceKeyFunc</code>, 即 f(obj) -&gt; namespace/name<br>常用的 IndexFunc 则有 <code>MetaNamespaceIndexFunc</code>, 即 f(obj) -&gt; [namespace]</p>\n<h2 id=\"threadSafeMap\"><a href=\"#threadSafeMap\" class=\"headerlink\" title=\"threadSafeMap\"></a>threadSafeMap</h2><p><code>threadSafeMap</code> 是 <code>ThreadSafeStore</code> 的具体实现，通过 <code>sync.RWMutex</code> 实现线程安全。threadSafeMap 只能保证其定义的操作是线程安全的，直接对 Get/List 等操作返回的结果进行修改是无法保证的。</p>\n<p>threadSafeMap 的数据结构如下，它的增删查改操作主要就是操作 <code>items</code>，同时通过 indexers 计算资源对象在各个索引中的值，通过  <code>updateIndices</code> 和 <code>deleteFromIndices</code> 对 <code>indices</code> 进行更新。</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> threadSafeMap <span class=\"hljs-keyword\">struct</span> &#123;\n    lock  sync.RWMutex\n    items <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]<span class=\"hljs-keyword\">interface</span>&#123;&#125;\n\n    <span class=\"hljs-comment\">// indexers maps a name to an IndexFunc</span>\n    indexers Indexers\n    <span class=\"hljs-comment\">// indices maps a name to an Index</span>\n    indices Indices\n&#125;</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><a href=\"https://github.com/kubernetes/client-go/blob/d1a4fe5f2d96df815903781843870155cb4f5f40/tools/cache/index.go#L35\"><code>Indexer</code></a> 是 kubernetes 中用于在内存中缓存资源对象的接口，支持通过 Key 对存储的资源对象进行增、删、查、改操作， 同时也可以对存储的对象进行倒排索引。</p>\n<p><code>cache</code> 是 <code>Indexer</code> 的实现方式，其定义如下：</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> cache <span class=\"hljs-keyword\">struct</span> &#123;\n    cacheStorage    ThreadSafeStore\n    keyFunc         KeyFunc\n&#125;</code></pre>\n\n<p><code>ThreadSafeStore</code> 定义了一个线程安全的存储接口，由 <code>threadSafeMap</code> 实现。</p>\n<p>ThreadSafeStore 与 Indexer 非常相似，前者可以看作是后者的一种特例。ThreadSafeStore 操作资源对象时需要指定对象的 key，而 Indexer 则不需要，是在 Indexer 的实现结构 cache 中通过 <code>keyFunc</code> 动态计算资源对象的 key。因此可以认为 <code>Indexer = ThreadSafeStore + KeyFunc</code>。</p>\n<h2 id=\"Indexer\"><a href=\"#Indexer\" class=\"headerlink\" title=\"Indexer\"></a>Indexer</h2><p>Indexer 与其它数据结构的关系如下：<br><img src=\"http://lc-c7oxru7u.cn-n1.lcfile.com/c34bc3865ff4230a648a.png/diagram-16025179975213868166.png\" alt=\"Indexer UML\"></p>\n<p>从图中可以看出没有索引的 cache 就是一个 Store，源码中 Indexer 和 Store 的创建方式分别如下：</p>\n<pre><code class=\"hljs GO\"><span class=\"hljs-comment\">// NewStore returns a Store implemented simply with a map and a lock.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">NewStore</span><span class=\"hljs-params\">(keyFunc KeyFunc)</span> <span class=\"hljs-title\">Store</span></span> &#123;\n    <span class=\"hljs-keyword\">return</span> &amp;cache&#123;\n        cacheStorage: NewThreadSafeStore(Indexers&#123;&#125;, Indices&#123;&#125;),\n        keyFunc:      keyFunc,\n    &#125;\n&#125;\n\n<span class=\"hljs-comment\">// NewIndexer returns an Indexer implemented simply with a map and a lock.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">NewIndexer</span><span class=\"hljs-params\">(keyFunc KeyFunc, indexers Indexers)</span> <span class=\"hljs-title\">Indexer</span></span> &#123;\n    <span class=\"hljs-keyword\">return</span> &amp;cache&#123;\n        cacheStorage: NewThreadSafeStore(indexers, Indices&#123;&#125;),\n        keyFunc:      keyFunc,\n    &#125;\n\n<span class=\"hljs-keyword\">type</span> KeyFunc <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(obj <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">string</span>, error)</span></span></code></pre>\n\n<p><code>ThreadSafeStore</code> 通过 <code>indexers</code> 创建索引，indexers 是一个如下的 map：</p>\n<pre><code class=\"hljs GO\"><span class=\"hljs-keyword\">type</span> Indexers <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]IndexFunc\n\n<span class=\"hljs-keyword\">type</span> IndexFunc <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(obj <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span> <span class=\"hljs-params\">([]<span class=\"hljs-keyword\">string</span>, error)</span></span></code></pre>\n\n<p>Indexers 的 Key 是索引名称，值是 <em>根据资源对象创建计算该索引的索引值的函数</em></p>\n<p><code>Indices</code> 是存储倒排索引的数据结构：</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> Indices <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]Index\n\n<span class=\"hljs-keyword\">type</span> Index <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]sets.String</code></pre>\n\n<p>Indices 的 Key 是索引名, 值是对应的索引 Index<br>Index 的 Key 是索引值，值是具有该索引值的资源对象的 Key</p>\n<h2 id=\"KeyFunc-与-IndexFunc\"><a href=\"#KeyFunc-与-IndexFunc\" class=\"headerlink\" title=\"KeyFunc 与 IndexFunc\"></a>KeyFunc 与 IndexFunc</h2><p>KeyFunc 与 IndexFunc 对比如下：</p>\n<ul>\n<li>KeyFunc: f(obj) -&gt; key</li>\n<li>IndexFunc: f(obj) -&gt; indexValue1, indexValue2 …</li>\n</ul>\n<p>由上对比可知 KeyFunc 是 IndexFunc 的一个特例，当 IndexFunc 只返回一个索引值时它就退化为 KeyFunc，client-go 中也提供了由 IndexFunc 到 KeyFunc 的适配函数：</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">IndexFuncToKeyFuncAdapter</span><span class=\"hljs-params\">(indexFunc IndexFunc)</span> <span class=\"hljs-title\">KeyFunc</span></span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(obj <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">string</span>, error)</span></span> &#123;\n        indexKeys, err := indexFunc(obj)\n        <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>, err\n        &#125;\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(indexKeys) &gt; <span class=\"hljs-number\">1</span> &#123;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>, fmt.Errorf(<span class=\"hljs-string\">&quot;too many keys: %v&quot;</span>, indexKeys)\n        &#125;\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(indexKeys) == <span class=\"hljs-number\">0</span> &#123;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>, fmt.Errorf(<span class=\"hljs-string\">&quot;unexpected empty indexKeys&quot;</span>)\n        &#125;\n        <span class=\"hljs-keyword\">return</span> indexKeys[<span class=\"hljs-number\">0</span>], <span class=\"hljs-literal\">nil</span>\n    &#125;\n&#125;</code></pre>\n\n<p>常用的 KeyFunc 有 <code>MetaNamespaceKeyFunc</code>, 即 f(obj) -&gt; namespace/name<br>常用的 IndexFunc 则有 <code>MetaNamespaceIndexFunc</code>, 即 f(obj) -&gt; [namespace]</p>\n<h2 id=\"threadSafeMap\"><a href=\"#threadSafeMap\" class=\"headerlink\" title=\"threadSafeMap\"></a>threadSafeMap</h2><p><code>threadSafeMap</code> 是 <code>ThreadSafeStore</code> 的具体实现，通过 <code>sync.RWMutex</code> 实现线程安全。threadSafeMap 只能保证其定义的操作是线程安全的，直接对 Get/List 等操作返回的结果进行修改是无法保证的。</p>\n<p>threadSafeMap 的数据结构如下，它的增删查改操作主要就是操作 <code>items</code>，同时通过 indexers 计算资源对象在各个索引中的值，通过  <code>updateIndices</code> 和 <code>deleteFromIndices</code> 对 <code>indices</code> 进行更新。</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> threadSafeMap <span class=\"hljs-keyword\">struct</span> &#123;\n    lock  sync.RWMutex\n    items <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]<span class=\"hljs-keyword\">interface</span>&#123;&#125;\n\n    <span class=\"hljs-comment\">// indexers maps a name to an IndexFunc</span>\n    indexers Indexers\n    <span class=\"hljs-comment\">// indices maps a name to an Index</span>\n    indices Indices\n&#125;</code></pre>\n"},{"title":"Kubernetes 源码阅读 -- Expiring","date":"2021-01-02T13:54:45.000Z","_content":"\n## 概述\n\n[`Expiring`](https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/cache/expiring.go) 是 Kubernets 中的一个 **带有过期时间的键值对缓存**，位于 `k8s.io/apimachinery` 模块的 `pkg/util/cache` 包中。\n\n`Expiring` 具有以下功能与特性：\n\n- 可以存取任意类型的键值对\n- 键值对在过期后会被自动清除\n- 线程安全\n\n``` Go\n// 添加带过期时间的键值对\nfunc (c *Expiring) Set(key interface{}, val interface{}, ttl time.Duration)\n\n// 根据 key 获取 value\nfunc (c *Expiring) Get(key interface{}) (val interface{}, ok bool)\n\n// 根据 key 删除键值对\nfunc (c *Expiring) Delete(key interface{})\n\n// 获取 Expiring 中存储的键值对数量\nfunc (c *Expiring) Len()\n```\n\n## Expiring 的数据结构\n\n基于上述的功能与特性，`Expiring` 提供了以下方法：\n\n`Expiring` 的数据结构设计如下：\n\n``` Go\ntype Expiring struct {\n    // 时钟接口，使用该接口主要是为了便于测试\n    // 在 Expiring 中用到其中的 Now 方法，该方法可以直接看作 time.Now\n    clock utilclock.Clock\n    // 读写锁，用于保证线程安全\n    mu sync.RWMutex\n    // 实际存储键值对的数据结构\n    cache map[interface{}]entry\n    // 全局版本号，用来实现键值对过期时间的更新\n    generation uint64\n    // 存储过期时间的最小堆\n    heap expiringHeap\n}\n```\n\n其中 `entry` 的数据结构如下：\n\n``` Go\ntype entry struct {\n    // 用户输入的 value\n    val        interface{}\n    // 用户指定的过期时间\n    expiry     time.Time\n    // 存储当前键值对时 Expiring 的版本号\n    generation uint64\n}\n```\n\n### expiringHeap\n\n[`expiringHeap`](https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/cache/expiring.go#L168) 是一个存储键值对过期时间的最小堆，其数据结构如下：\n\n``` Go\ntype expiringHeap []*expiringHeapEntry\n\ntype expiringHeapEntry struct {\n    // 用户输入的 key\n    key        interface{}\n    // 过期时间\n    expiry     time.Time\n    // 存储当前键值对时 Expiring 的版本号\n    generation uint64\n}\n\n// expiringHeap 实现了 heap.Interface 接口\n// 即可以当作堆来使用\nvar _ heap.Interface = &expiringHeap{}\n\n// 比较的是过期时间\n// expiringHeapEntry 中的元素 i 小于 元素 j 当且仅当 i 的过期时间小于 j 的过期时间\nfunc (cq expiringHeap) Less(i, j int) bool {\n    return cq[i].expiry.Before(cq[j].expiry)\n}\n\n// heap.Interface 的其它方法的实现较为常见，在此忽略\n```\n\n## Expiring 的实现\n\n### Set\n\n``` Go\nfunc (c *Expiring) Set(key interface{}, val interface{}, ttl time.Duration) {\n    // 计算超时时间\n    now := c.clock.Now()\n    expiry := now.Add(ttl)\n\n    // 加写锁保证线程安全\n    c.mu.Lock()\n    defer c.mu.Unlock()\n\n    // 全局版本号自增\n    c.generation++\n\n    // 存储 value\n    c.cache[key] = entry{\n        val:        val,\n        expiry:     expiry,\n        generation: c.generation,\n    }\n\n    // 清理已过期的键值对\n    // Run GC inline before pushing the new entry.\n    c.gc(now)\n\n    // 过期时间存入最小堆中\n    heap.Push(&c.heap, &expiringHeapEntry{\n        key:        key,\n        expiry:     expiry,\n        generation: c.generation,\n    })\n}\n```\n\n#### Get\n\n``` Go\nfunc (c *Expiring) Get(key interface{}) (val interface{}, ok bool) {\n    // 加读锁保证线程安全\n    c.mu.RLock()\n    defer c.mu.RUnlock()\n    e, ok := c.cache[key]\n    if !ok || !c.clock.Now().Before(e.expiry) {\n        // 如果键值对存在但已过期则当作不存在返回\n        return nil, false\n    }\n    return e.val, true\n}\n```\n\n### 清理过期的键值对\n\n``` Go\n// 将 Expiring 所有过期的键值对清除\nfunc (c *Expiring) gc(now time.Time) {\n    for {\n        if len(c.heap) == 0 || now.Before(c.heap[0].expiry) {\n            // 因为过期时间的 entry 以最小堆的形式组织\n            // 所以如果第一个元素没有过期的话其余的元素也肯定没有过期\n            return\n        }\n        cleanup := heap.Pop(&c.heap).(*expiringHeapEntry)\n        // 执行清理操作\n        c.del(cleanup.key, cleanup.generation)\n    }\n}\n\nfunc (c *Expiring) del(key interface{}, generation uint64) {\n    e, ok := c.cache[key]\n    if !ok {\n        return\n    }\n    // generation == 0 标识该方法是由 Delete 调用的，键值对一定需要删除\n    // generation != 0 则说明该方法由 gc 调用\n    //      当 gc 调用该方法时如果该键值对在 cache 中存储的过期时间与在最小堆中存储的版本号不一致则说明\n    //      该键值对被更新过，当前的过期时间 entry 已经无效了，忽略就行（堆中还存在着该键值对的其它过期时间 entry）\n    if generation != 0 && generation != e.generation {\n        return\n    }\n    delete(c.cache, key)\n}\n\nfunc (c *Expiring) Delete(key interface{}) {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    c.del(key, 0)\n}\n```\n\n### utilclock.Clock\n\n在测试 `Expiring` 时，添加键值对需要指定过期时间，这可能导致测试时间变得很长，\n`Expiring` 中引入 [`utilclock.Clock`](https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/clock/clock.go) 能够让测试变得更加简单迅速。\n\n在实际使用时，`Expiring` 使用的是 [`RealClock`](https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/clock/clock.go#L43)，它使用的是真实的时间。\n\n而在测试时则可以使用 [`FakeClock`](https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/clock/clock.go#L85) 来 “快进” 到任意时间。\n\n下一篇文章将对 `Clock` 进行详细的介绍。\n","source":"_posts/Kubernetes-源码阅读-Expiring.md","raw":"---\ntitle: Kubernetes 源码阅读 -- Expiring\ndate: 2021-01-02 21:54:45\ntags: [k8s, 源码, cache, apimachinery]\ncategories: kubernetes\n---\n\n## 概述\n\n[`Expiring`](https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/cache/expiring.go) 是 Kubernets 中的一个 **带有过期时间的键值对缓存**，位于 `k8s.io/apimachinery` 模块的 `pkg/util/cache` 包中。\n\n`Expiring` 具有以下功能与特性：\n\n- 可以存取任意类型的键值对\n- 键值对在过期后会被自动清除\n- 线程安全\n\n``` Go\n// 添加带过期时间的键值对\nfunc (c *Expiring) Set(key interface{}, val interface{}, ttl time.Duration)\n\n// 根据 key 获取 value\nfunc (c *Expiring) Get(key interface{}) (val interface{}, ok bool)\n\n// 根据 key 删除键值对\nfunc (c *Expiring) Delete(key interface{})\n\n// 获取 Expiring 中存储的键值对数量\nfunc (c *Expiring) Len()\n```\n\n## Expiring 的数据结构\n\n基于上述的功能与特性，`Expiring` 提供了以下方法：\n\n`Expiring` 的数据结构设计如下：\n\n``` Go\ntype Expiring struct {\n    // 时钟接口，使用该接口主要是为了便于测试\n    // 在 Expiring 中用到其中的 Now 方法，该方法可以直接看作 time.Now\n    clock utilclock.Clock\n    // 读写锁，用于保证线程安全\n    mu sync.RWMutex\n    // 实际存储键值对的数据结构\n    cache map[interface{}]entry\n    // 全局版本号，用来实现键值对过期时间的更新\n    generation uint64\n    // 存储过期时间的最小堆\n    heap expiringHeap\n}\n```\n\n其中 `entry` 的数据结构如下：\n\n``` Go\ntype entry struct {\n    // 用户输入的 value\n    val        interface{}\n    // 用户指定的过期时间\n    expiry     time.Time\n    // 存储当前键值对时 Expiring 的版本号\n    generation uint64\n}\n```\n\n### expiringHeap\n\n[`expiringHeap`](https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/cache/expiring.go#L168) 是一个存储键值对过期时间的最小堆，其数据结构如下：\n\n``` Go\ntype expiringHeap []*expiringHeapEntry\n\ntype expiringHeapEntry struct {\n    // 用户输入的 key\n    key        interface{}\n    // 过期时间\n    expiry     time.Time\n    // 存储当前键值对时 Expiring 的版本号\n    generation uint64\n}\n\n// expiringHeap 实现了 heap.Interface 接口\n// 即可以当作堆来使用\nvar _ heap.Interface = &expiringHeap{}\n\n// 比较的是过期时间\n// expiringHeapEntry 中的元素 i 小于 元素 j 当且仅当 i 的过期时间小于 j 的过期时间\nfunc (cq expiringHeap) Less(i, j int) bool {\n    return cq[i].expiry.Before(cq[j].expiry)\n}\n\n// heap.Interface 的其它方法的实现较为常见，在此忽略\n```\n\n## Expiring 的实现\n\n### Set\n\n``` Go\nfunc (c *Expiring) Set(key interface{}, val interface{}, ttl time.Duration) {\n    // 计算超时时间\n    now := c.clock.Now()\n    expiry := now.Add(ttl)\n\n    // 加写锁保证线程安全\n    c.mu.Lock()\n    defer c.mu.Unlock()\n\n    // 全局版本号自增\n    c.generation++\n\n    // 存储 value\n    c.cache[key] = entry{\n        val:        val,\n        expiry:     expiry,\n        generation: c.generation,\n    }\n\n    // 清理已过期的键值对\n    // Run GC inline before pushing the new entry.\n    c.gc(now)\n\n    // 过期时间存入最小堆中\n    heap.Push(&c.heap, &expiringHeapEntry{\n        key:        key,\n        expiry:     expiry,\n        generation: c.generation,\n    })\n}\n```\n\n#### Get\n\n``` Go\nfunc (c *Expiring) Get(key interface{}) (val interface{}, ok bool) {\n    // 加读锁保证线程安全\n    c.mu.RLock()\n    defer c.mu.RUnlock()\n    e, ok := c.cache[key]\n    if !ok || !c.clock.Now().Before(e.expiry) {\n        // 如果键值对存在但已过期则当作不存在返回\n        return nil, false\n    }\n    return e.val, true\n}\n```\n\n### 清理过期的键值对\n\n``` Go\n// 将 Expiring 所有过期的键值对清除\nfunc (c *Expiring) gc(now time.Time) {\n    for {\n        if len(c.heap) == 0 || now.Before(c.heap[0].expiry) {\n            // 因为过期时间的 entry 以最小堆的形式组织\n            // 所以如果第一个元素没有过期的话其余的元素也肯定没有过期\n            return\n        }\n        cleanup := heap.Pop(&c.heap).(*expiringHeapEntry)\n        // 执行清理操作\n        c.del(cleanup.key, cleanup.generation)\n    }\n}\n\nfunc (c *Expiring) del(key interface{}, generation uint64) {\n    e, ok := c.cache[key]\n    if !ok {\n        return\n    }\n    // generation == 0 标识该方法是由 Delete 调用的，键值对一定需要删除\n    // generation != 0 则说明该方法由 gc 调用\n    //      当 gc 调用该方法时如果该键值对在 cache 中存储的过期时间与在最小堆中存储的版本号不一致则说明\n    //      该键值对被更新过，当前的过期时间 entry 已经无效了，忽略就行（堆中还存在着该键值对的其它过期时间 entry）\n    if generation != 0 && generation != e.generation {\n        return\n    }\n    delete(c.cache, key)\n}\n\nfunc (c *Expiring) Delete(key interface{}) {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    c.del(key, 0)\n}\n```\n\n### utilclock.Clock\n\n在测试 `Expiring` 时，添加键值对需要指定过期时间，这可能导致测试时间变得很长，\n`Expiring` 中引入 [`utilclock.Clock`](https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/clock/clock.go) 能够让测试变得更加简单迅速。\n\n在实际使用时，`Expiring` 使用的是 [`RealClock`](https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/clock/clock.go#L43)，它使用的是真实的时间。\n\n而在测试时则可以使用 [`FakeClock`](https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/clock/clock.go#L85) 来 “快进” 到任意时间。\n\n下一篇文章将对 `Clock` 进行详细的介绍。\n","slug":"Kubernetes-源码阅读-Expiring","published":1,"updated":"2021-01-02T15:46:57.823Z","_id":"ckjfvo33j00003ns6frt9bcsu","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><a href=\"https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/cache/expiring.go\"><code>Expiring</code></a> 是 Kubernets 中的一个 <strong>带有过期时间的键值对缓存</strong>，位于 <code>k8s.io/apimachinery</code> 模块的 <code>pkg/util/cache</code> 包中。</p>\n<p><code>Expiring</code> 具有以下功能与特性：</p>\n<ul>\n<li>可以存取任意类型的键值对</li>\n<li>键值对在过期后会被自动清除</li>\n<li>线程安全</li>\n</ul>\n<pre><code class=\"hljs Go\"><span class=\"hljs-comment\">// 添加带过期时间的键值对</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Set</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;, val <span class=\"hljs-keyword\">interface</span>&#123;&#125;, ttl time.Duration)</span></span>\n\n<span class=\"hljs-comment\">// 根据 key 获取 value</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Get</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span> <span class=\"hljs-params\">(val <span class=\"hljs-keyword\">interface</span>&#123;&#125;, ok <span class=\"hljs-keyword\">bool</span>)</span></span>\n\n<span class=\"hljs-comment\">// 根据 key 删除键值对</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Delete</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span></span>\n\n<span class=\"hljs-comment\">// 获取 Expiring 中存储的键值对数量</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Len</span><span class=\"hljs-params\">()</span></span></code></pre>\n\n<h2 id=\"Expiring-的数据结构\"><a href=\"#Expiring-的数据结构\" class=\"headerlink\" title=\"Expiring 的数据结构\"></a>Expiring 的数据结构</h2><p>基于上述的功能与特性，<code>Expiring</code> 提供了以下方法：</p>\n<p><code>Expiring</code> 的数据结构设计如下：</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> Expiring <span class=\"hljs-keyword\">struct</span> &#123;\n    <span class=\"hljs-comment\">// 时钟接口，使用该接口主要是为了便于测试</span>\n    <span class=\"hljs-comment\">// 在 Expiring 中用到其中的 Now 方法，该方法可以直接看作 time.Now</span>\n    clock utilclock.Clock\n    <span class=\"hljs-comment\">// 读写锁，用于保证线程安全</span>\n    mu sync.RWMutex\n    <span class=\"hljs-comment\">// 实际存储键值对的数据结构</span>\n    cache <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">interface</span>&#123;&#125;]entry\n    <span class=\"hljs-comment\">// 全局版本号，用来实现键值对过期时间的更新</span>\n    generation <span class=\"hljs-keyword\">uint64</span>\n    <span class=\"hljs-comment\">// 存储过期时间的最小堆</span>\n    heap expiringHeap\n&#125;</code></pre>\n\n<p>其中 <code>entry</code> 的数据结构如下：</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> entry <span class=\"hljs-keyword\">struct</span> &#123;\n    <span class=\"hljs-comment\">// 用户输入的 value</span>\n    val        <span class=\"hljs-keyword\">interface</span>&#123;&#125;\n    <span class=\"hljs-comment\">// 用户指定的过期时间</span>\n    expiry     time.Time\n    <span class=\"hljs-comment\">// 存储当前键值对时 Expiring 的版本号</span>\n    generation <span class=\"hljs-keyword\">uint64</span>\n&#125;</code></pre>\n\n<h3 id=\"expiringHeap\"><a href=\"#expiringHeap\" class=\"headerlink\" title=\"expiringHeap\"></a>expiringHeap</h3><p><a href=\"https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/cache/expiring.go#L168\"><code>expiringHeap</code></a> 是一个存储键值对过期时间的最小堆，其数据结构如下：</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> expiringHeap []*expiringHeapEntry\n\n<span class=\"hljs-keyword\">type</span> expiringHeapEntry <span class=\"hljs-keyword\">struct</span> &#123;\n    <span class=\"hljs-comment\">// 用户输入的 key</span>\n    key        <span class=\"hljs-keyword\">interface</span>&#123;&#125;\n    <span class=\"hljs-comment\">// 过期时间</span>\n    expiry     time.Time\n    <span class=\"hljs-comment\">// 存储当前键值对时 Expiring 的版本号</span>\n    generation <span class=\"hljs-keyword\">uint64</span>\n&#125;\n\n<span class=\"hljs-comment\">// expiringHeap 实现了 heap.Interface 接口</span>\n<span class=\"hljs-comment\">// 即可以当作堆来使用</span>\n<span class=\"hljs-keyword\">var</span> _ heap.Interface = &amp;expiringHeap&#123;&#125;\n\n<span class=\"hljs-comment\">// 比较的是过期时间</span>\n<span class=\"hljs-comment\">// expiringHeapEntry 中的元素 i 小于 元素 j 当且仅当 i 的过期时间小于 j 的过期时间</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(cq expiringHeap)</span> <span class=\"hljs-title\">Less</span><span class=\"hljs-params\">(i, j <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">bool</span></span> &#123;\n    <span class=\"hljs-keyword\">return</span> cq[i].expiry.Before(cq[j].expiry)\n&#125;\n\n<span class=\"hljs-comment\">// heap.Interface 的其它方法的实现较为常见，在此忽略</span></code></pre>\n\n<h2 id=\"Expiring-的实现\"><a href=\"#Expiring-的实现\" class=\"headerlink\" title=\"Expiring 的实现\"></a>Expiring 的实现</h2><h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Set</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;, val <span class=\"hljs-keyword\">interface</span>&#123;&#125;, ttl time.Duration)</span></span> &#123;\n    <span class=\"hljs-comment\">// 计算超时时间</span>\n    now := c.clock.Now()\n    expiry := now.Add(ttl)\n\n    <span class=\"hljs-comment\">// 加写锁保证线程安全</span>\n    c.mu.Lock()\n    <span class=\"hljs-keyword\">defer</span> c.mu.Unlock()\n\n    <span class=\"hljs-comment\">// 全局版本号自增</span>\n    c.generation++\n\n    <span class=\"hljs-comment\">// 存储 value</span>\n    c.cache[key] = entry&#123;\n        val:        val,\n        expiry:     expiry,\n        generation: c.generation,\n    &#125;\n\n    <span class=\"hljs-comment\">// 清理已过期的键值对</span>\n    <span class=\"hljs-comment\">// Run GC inline before pushing the new entry.</span>\n    c.gc(now)\n\n    <span class=\"hljs-comment\">// 过期时间存入最小堆中</span>\n    heap.Push(&amp;c.heap, &amp;expiringHeapEntry&#123;\n        key:        key,\n        expiry:     expiry,\n        generation: c.generation,\n    &#125;)\n&#125;</code></pre>\n\n<h4 id=\"Get\"><a href=\"#Get\" class=\"headerlink\" title=\"Get\"></a>Get</h4><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Get</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span> <span class=\"hljs-params\">(val <span class=\"hljs-keyword\">interface</span>&#123;&#125;, ok <span class=\"hljs-keyword\">bool</span>)</span></span> &#123;\n    <span class=\"hljs-comment\">// 加读锁保证线程安全</span>\n    c.mu.RLock()\n    <span class=\"hljs-keyword\">defer</span> c.mu.RUnlock()\n    e, ok := c.cache[key]\n    <span class=\"hljs-keyword\">if</span> !ok || !c.clock.Now().Before(e.expiry) &#123;\n        <span class=\"hljs-comment\">// 如果键值对存在但已过期则当作不存在返回</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, <span class=\"hljs-literal\">false</span>\n    &#125;\n    <span class=\"hljs-keyword\">return</span> e.val, <span class=\"hljs-literal\">true</span>\n&#125;</code></pre>\n\n<h3 id=\"清理过期的键值对\"><a href=\"#清理过期的键值对\" class=\"headerlink\" title=\"清理过期的键值对\"></a>清理过期的键值对</h3><pre><code class=\"hljs Go\"><span class=\"hljs-comment\">// 将 Expiring 所有过期的键值对清除</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">gc</span><span class=\"hljs-params\">(now time.Time)</span></span> &#123;\n    <span class=\"hljs-keyword\">for</span> &#123;\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(c.heap) == <span class=\"hljs-number\">0</span> || now.Before(c.heap[<span class=\"hljs-number\">0</span>].expiry) &#123;\n            <span class=\"hljs-comment\">// 因为过期时间的 entry 以最小堆的形式组织</span>\n            <span class=\"hljs-comment\">// 所以如果第一个元素没有过期的话其余的元素也肯定没有过期</span>\n            <span class=\"hljs-keyword\">return</span>\n        &#125;\n        cleanup := heap.Pop(&amp;c.heap).(*expiringHeapEntry)\n        <span class=\"hljs-comment\">// 执行清理操作</span>\n        c.del(cleanup.key, cleanup.generation)\n    &#125;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">del</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;, generation <span class=\"hljs-keyword\">uint64</span>)</span></span> &#123;\n    e, ok := c.cache[key]\n    <span class=\"hljs-keyword\">if</span> !ok &#123;\n        <span class=\"hljs-keyword\">return</span>\n    &#125;\n    <span class=\"hljs-comment\">// generation == 0 标识该方法是由 Delete 调用的，键值对一定需要删除</span>\n    <span class=\"hljs-comment\">// generation != 0 则说明该方法由 gc 调用</span>\n    <span class=\"hljs-comment\">//      当 gc 调用该方法时如果该键值对在 cache 中存储的过期时间与在最小堆中存储的版本号不一致则说明</span>\n    <span class=\"hljs-comment\">//      该键值对被更新过，当前的过期时间 entry 已经无效了，忽略就行（堆中还存在着该键值对的其它过期时间 entry）</span>\n    <span class=\"hljs-keyword\">if</span> generation != <span class=\"hljs-number\">0</span> &amp;&amp; generation != e.generation &#123;\n        <span class=\"hljs-keyword\">return</span>\n    &#125;\n    <span class=\"hljs-built_in\">delete</span>(c.cache, key)\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Delete</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span></span> &#123;\n    c.mu.Lock()\n    <span class=\"hljs-keyword\">defer</span> c.mu.Unlock()\n    c.del(key, <span class=\"hljs-number\">0</span>)\n&#125;</code></pre>\n\n<h3 id=\"utilclock-Clock\"><a href=\"#utilclock-Clock\" class=\"headerlink\" title=\"utilclock.Clock\"></a>utilclock.Clock</h3><p>在测试 <code>Expiring</code> 时，添加键值对需要指定过期时间，这可能导致测试时间变得很长，<br><code>Expiring</code> 中引入 <a href=\"https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/clock/clock.go\"><code>utilclock.Clock</code></a> 能够让测试变得更加简单迅速。</p>\n<p>在实际使用时，<code>Expiring</code> 使用的是 <a href=\"https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/clock/clock.go#L43\"><code>RealClock</code></a>，它使用的是真实的时间。</p>\n<p>而在测试时则可以使用 <a href=\"https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/clock/clock.go#L85\"><code>FakeClock</code></a> 来 “快进” 到任意时间。</p>\n<p>下一篇文章将对 <code>Clock</code> 进行详细的介绍。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><a href=\"https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/cache/expiring.go\"><code>Expiring</code></a> 是 Kubernets 中的一个 <strong>带有过期时间的键值对缓存</strong>，位于 <code>k8s.io/apimachinery</code> 模块的 <code>pkg/util/cache</code> 包中。</p>\n<p><code>Expiring</code> 具有以下功能与特性：</p>\n<ul>\n<li>可以存取任意类型的键值对</li>\n<li>键值对在过期后会被自动清除</li>\n<li>线程安全</li>\n</ul>\n<pre><code class=\"hljs Go\"><span class=\"hljs-comment\">// 添加带过期时间的键值对</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Set</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;, val <span class=\"hljs-keyword\">interface</span>&#123;&#125;, ttl time.Duration)</span></span>\n\n<span class=\"hljs-comment\">// 根据 key 获取 value</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Get</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span> <span class=\"hljs-params\">(val <span class=\"hljs-keyword\">interface</span>&#123;&#125;, ok <span class=\"hljs-keyword\">bool</span>)</span></span>\n\n<span class=\"hljs-comment\">// 根据 key 删除键值对</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Delete</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span></span>\n\n<span class=\"hljs-comment\">// 获取 Expiring 中存储的键值对数量</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Len</span><span class=\"hljs-params\">()</span></span></code></pre>\n\n<h2 id=\"Expiring-的数据结构\"><a href=\"#Expiring-的数据结构\" class=\"headerlink\" title=\"Expiring 的数据结构\"></a>Expiring 的数据结构</h2><p>基于上述的功能与特性，<code>Expiring</code> 提供了以下方法：</p>\n<p><code>Expiring</code> 的数据结构设计如下：</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> Expiring <span class=\"hljs-keyword\">struct</span> &#123;\n    <span class=\"hljs-comment\">// 时钟接口，使用该接口主要是为了便于测试</span>\n    <span class=\"hljs-comment\">// 在 Expiring 中用到其中的 Now 方法，该方法可以直接看作 time.Now</span>\n    clock utilclock.Clock\n    <span class=\"hljs-comment\">// 读写锁，用于保证线程安全</span>\n    mu sync.RWMutex\n    <span class=\"hljs-comment\">// 实际存储键值对的数据结构</span>\n    cache <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">interface</span>&#123;&#125;]entry\n    <span class=\"hljs-comment\">// 全局版本号，用来实现键值对过期时间的更新</span>\n    generation <span class=\"hljs-keyword\">uint64</span>\n    <span class=\"hljs-comment\">// 存储过期时间的最小堆</span>\n    heap expiringHeap\n&#125;</code></pre>\n\n<p>其中 <code>entry</code> 的数据结构如下：</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> entry <span class=\"hljs-keyword\">struct</span> &#123;\n    <span class=\"hljs-comment\">// 用户输入的 value</span>\n    val        <span class=\"hljs-keyword\">interface</span>&#123;&#125;\n    <span class=\"hljs-comment\">// 用户指定的过期时间</span>\n    expiry     time.Time\n    <span class=\"hljs-comment\">// 存储当前键值对时 Expiring 的版本号</span>\n    generation <span class=\"hljs-keyword\">uint64</span>\n&#125;</code></pre>\n\n<h3 id=\"expiringHeap\"><a href=\"#expiringHeap\" class=\"headerlink\" title=\"expiringHeap\"></a>expiringHeap</h3><p><a href=\"https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/cache/expiring.go#L168\"><code>expiringHeap</code></a> 是一个存储键值对过期时间的最小堆，其数据结构如下：</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> expiringHeap []*expiringHeapEntry\n\n<span class=\"hljs-keyword\">type</span> expiringHeapEntry <span class=\"hljs-keyword\">struct</span> &#123;\n    <span class=\"hljs-comment\">// 用户输入的 key</span>\n    key        <span class=\"hljs-keyword\">interface</span>&#123;&#125;\n    <span class=\"hljs-comment\">// 过期时间</span>\n    expiry     time.Time\n    <span class=\"hljs-comment\">// 存储当前键值对时 Expiring 的版本号</span>\n    generation <span class=\"hljs-keyword\">uint64</span>\n&#125;\n\n<span class=\"hljs-comment\">// expiringHeap 实现了 heap.Interface 接口</span>\n<span class=\"hljs-comment\">// 即可以当作堆来使用</span>\n<span class=\"hljs-keyword\">var</span> _ heap.Interface = &amp;expiringHeap&#123;&#125;\n\n<span class=\"hljs-comment\">// 比较的是过期时间</span>\n<span class=\"hljs-comment\">// expiringHeapEntry 中的元素 i 小于 元素 j 当且仅当 i 的过期时间小于 j 的过期时间</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(cq expiringHeap)</span> <span class=\"hljs-title\">Less</span><span class=\"hljs-params\">(i, j <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">bool</span></span> &#123;\n    <span class=\"hljs-keyword\">return</span> cq[i].expiry.Before(cq[j].expiry)\n&#125;\n\n<span class=\"hljs-comment\">// heap.Interface 的其它方法的实现较为常见，在此忽略</span></code></pre>\n\n<h2 id=\"Expiring-的实现\"><a href=\"#Expiring-的实现\" class=\"headerlink\" title=\"Expiring 的实现\"></a>Expiring 的实现</h2><h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Set</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;, val <span class=\"hljs-keyword\">interface</span>&#123;&#125;, ttl time.Duration)</span></span> &#123;\n    <span class=\"hljs-comment\">// 计算超时时间</span>\n    now := c.clock.Now()\n    expiry := now.Add(ttl)\n\n    <span class=\"hljs-comment\">// 加写锁保证线程安全</span>\n    c.mu.Lock()\n    <span class=\"hljs-keyword\">defer</span> c.mu.Unlock()\n\n    <span class=\"hljs-comment\">// 全局版本号自增</span>\n    c.generation++\n\n    <span class=\"hljs-comment\">// 存储 value</span>\n    c.cache[key] = entry&#123;\n        val:        val,\n        expiry:     expiry,\n        generation: c.generation,\n    &#125;\n\n    <span class=\"hljs-comment\">// 清理已过期的键值对</span>\n    <span class=\"hljs-comment\">// Run GC inline before pushing the new entry.</span>\n    c.gc(now)\n\n    <span class=\"hljs-comment\">// 过期时间存入最小堆中</span>\n    heap.Push(&amp;c.heap, &amp;expiringHeapEntry&#123;\n        key:        key,\n        expiry:     expiry,\n        generation: c.generation,\n    &#125;)\n&#125;</code></pre>\n\n<h4 id=\"Get\"><a href=\"#Get\" class=\"headerlink\" title=\"Get\"></a>Get</h4><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Get</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span> <span class=\"hljs-params\">(val <span class=\"hljs-keyword\">interface</span>&#123;&#125;, ok <span class=\"hljs-keyword\">bool</span>)</span></span> &#123;\n    <span class=\"hljs-comment\">// 加读锁保证线程安全</span>\n    c.mu.RLock()\n    <span class=\"hljs-keyword\">defer</span> c.mu.RUnlock()\n    e, ok := c.cache[key]\n    <span class=\"hljs-keyword\">if</span> !ok || !c.clock.Now().Before(e.expiry) &#123;\n        <span class=\"hljs-comment\">// 如果键值对存在但已过期则当作不存在返回</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, <span class=\"hljs-literal\">false</span>\n    &#125;\n    <span class=\"hljs-keyword\">return</span> e.val, <span class=\"hljs-literal\">true</span>\n&#125;</code></pre>\n\n<h3 id=\"清理过期的键值对\"><a href=\"#清理过期的键值对\" class=\"headerlink\" title=\"清理过期的键值对\"></a>清理过期的键值对</h3><pre><code class=\"hljs Go\"><span class=\"hljs-comment\">// 将 Expiring 所有过期的键值对清除</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">gc</span><span class=\"hljs-params\">(now time.Time)</span></span> &#123;\n    <span class=\"hljs-keyword\">for</span> &#123;\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(c.heap) == <span class=\"hljs-number\">0</span> || now.Before(c.heap[<span class=\"hljs-number\">0</span>].expiry) &#123;\n            <span class=\"hljs-comment\">// 因为过期时间的 entry 以最小堆的形式组织</span>\n            <span class=\"hljs-comment\">// 所以如果第一个元素没有过期的话其余的元素也肯定没有过期</span>\n            <span class=\"hljs-keyword\">return</span>\n        &#125;\n        cleanup := heap.Pop(&amp;c.heap).(*expiringHeapEntry)\n        <span class=\"hljs-comment\">// 执行清理操作</span>\n        c.del(cleanup.key, cleanup.generation)\n    &#125;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">del</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;, generation <span class=\"hljs-keyword\">uint64</span>)</span></span> &#123;\n    e, ok := c.cache[key]\n    <span class=\"hljs-keyword\">if</span> !ok &#123;\n        <span class=\"hljs-keyword\">return</span>\n    &#125;\n    <span class=\"hljs-comment\">// generation == 0 标识该方法是由 Delete 调用的，键值对一定需要删除</span>\n    <span class=\"hljs-comment\">// generation != 0 则说明该方法由 gc 调用</span>\n    <span class=\"hljs-comment\">//      当 gc 调用该方法时如果该键值对在 cache 中存储的过期时间与在最小堆中存储的版本号不一致则说明</span>\n    <span class=\"hljs-comment\">//      该键值对被更新过，当前的过期时间 entry 已经无效了，忽略就行（堆中还存在着该键值对的其它过期时间 entry）</span>\n    <span class=\"hljs-keyword\">if</span> generation != <span class=\"hljs-number\">0</span> &amp;&amp; generation != e.generation &#123;\n        <span class=\"hljs-keyword\">return</span>\n    &#125;\n    <span class=\"hljs-built_in\">delete</span>(c.cache, key)\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Delete</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span></span> &#123;\n    c.mu.Lock()\n    <span class=\"hljs-keyword\">defer</span> c.mu.Unlock()\n    c.del(key, <span class=\"hljs-number\">0</span>)\n&#125;</code></pre>\n\n<h3 id=\"utilclock-Clock\"><a href=\"#utilclock-Clock\" class=\"headerlink\" title=\"utilclock.Clock\"></a>utilclock.Clock</h3><p>在测试 <code>Expiring</code> 时，添加键值对需要指定过期时间，这可能导致测试时间变得很长，<br><code>Expiring</code> 中引入 <a href=\"https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/clock/clock.go\"><code>utilclock.Clock</code></a> 能够让测试变得更加简单迅速。</p>\n<p>在实际使用时，<code>Expiring</code> 使用的是 <a href=\"https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/clock/clock.go#L43\"><code>RealClock</code></a>，它使用的是真实的时间。</p>\n<p>而在测试时则可以使用 <a href=\"https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/clock/clock.go#L85\"><code>FakeClock</code></a> 来 “快进” 到任意时间。</p>\n<p>下一篇文章将对 <code>Clock</code> 进行详细的介绍。</p>\n"},{"title":"go 标准库的 heap","date":"2021-01-31T14:05:38.000Z","_content":"\ngo 标准库提供的 [堆](https://en.wikipedia.org/wiki/Heap_(data_structure)) 虽然在 [`container`](https://github.com/golang/go/tree/master/src/container/heap) 包里，但它其实并没有像 `list` 和 `ring` 那样提供一个实实在在的容器，事实上它定义了一个如下的接口和一系列堆的基本操作，只要是实现了该接口的结构就可以被认为是一个堆，从而把堆的操作方法用到该结构上。\n\n```go\ntype Interface interface {\n    // 排序接口\n    sort.Interface\n    // 追加元素\n    Push(x interface{})\n    // 移除首个元素\n    Pop() interface{}\n}\n```\n\n**注意** `Interface` 中的 `Push` 和 `Pop` 方法是针对要实现该接口的数据接口本身的追加和移除操作，并非我们通常说的堆的 `Push` 和 `Pop` 方法，在使用堆时切记使用的是 `heap.Push(h, x)` 和 `heap.Pop(h)` 。\n\n## 堆的初始化\n\n```go\n// 把给定的结构初始化成一个 最小堆\nfunc Init(h Interface) {\n    n := h.Len()\n    // i = n / 2 - 1\n    // 2i + 1 = n - 1 => i 是 非叶子节点\n    // 对所有非叶子节点进行下沉操作\n    for i := n/2 - 1; i >= 0; i-- {\n        down(h, i, n)\n    }\n}\n\n// 节点下沉操作\n// n: 下沉操作的界限\nfunc down(h Interface, i0, n int) bool {\n    i := i0\n    for {\n        j1 := 2*i + 1\n        // 下沉是考虑的节点不超过 n\n        // 可以观察下 Init/Fix 和 Pop/Remove 时 n 的值\n        if j1 >= n || j1 < 0 { // j1 < 0 after int overflow\n            break\n        }\n        j := j1 // left child\n        // 选出左、右子节点中较小的\n        if j2 := j1 + 1; j2 < n && h.Less(j2, j1) {\n            j = j2 // = 2*i + 2  // right child\n        }\n        if !h.Less(j, i) {\n            // 子节点不小于父节点 (已经是有序的)\n            break\n        }\n        // 父节点与左、右子节点中较小的进行交换\n        h.Swap(i, j)\n        // 原来的父节点已经变为子节点，考虑是否还要继续下沉\n        i = j\n    }\n    // 返回 i0 节点是否下沉了\n    return i > i0\n}\n```\n\n## 插入元素\n\n```go\nfunc Push(h Interface, x interface{}) {\n    h.Push(x)\n    // 添加的元素是堆对应二叉树的最右下的节点\n    // 考虑该元素是否需要上浮\n    up(h, h.Len()-1)\n}\n\n// 元素上浮操作\nfunc up(h Interface, j int) {\n    for {\n        i := (j - 1) / 2 // parent\n        if i == j || !h.Less(j, i) {\n            // 该元素不小于父节点\n            break\n        }\n        // 与父节点交换\n        h.Swap(i, j)\n        // 考虑是否需要继续上浮\n        j = i\n    }\n}\n```\n\n## 弹出元素与移除某个元素\n\n```go\n// 移除堆的根节点\nfunc Pop(h Interface) interface{} {\n    n := h.Len() - 1\n    // 根节点与最后一个（最右下）元素交换\n    h.Swap(0, n)\n    // 对交换后的根节点进行下沉操作\n    // 注意下沉时的界限为 倒数第二个 元素 （不包括最后一个元素，否则就白交换了）\n    down(h, 0, n)\n    // 移除最后一个元素，即原来的根节点\n    return h.Pop()\n}\n\n// 移除堆的第 n 个节点\nfunc Remove(h Interface, i int) interface{} {\n    n := h.Len() - 1\n    // 如果是最后一个节点的话直接移除\n    if n != i {\n        h.Swap(i, n)\n        if !down(h, i, n) {\n            // 交换、下沉与 Pop 类似\n            // 因为 i 不一定是根节点，如果有下沉操作的话还要考虑是否要进行上浮\n            up(h, i)\n        }\n    }\n    return h.Pop()\n}\n```\n\n## 修复\n\n```go\n// 节点 i 的值发生变化后需要对堆进行修复\nfunc Fix(h Interface, i int) {\n    // 先下沉\n    if !down(h, i, h.Len()) {\n        // 如果有下沉操作则考虑上浮\n        up(h, i)\n    }\n}\n```\n\n## 使用示例\n\n使用堆实现 [Dijkstra's algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) 来解决 [Leetcode 1631. 最小体力消耗路径](https://leetcode-cn.com/problems/path-with-minimum-effort/) 问题：\n\n```go\ntype node struct {\n    x, y, distance int\n}\n\n// 定义堆\ntype nodeHeap []*node\n\nfunc (h nodeHeap) Len() int {\n    return len(h)\n}\n\nfunc (h nodeHeap) Less(i, j int) bool {\n    return h[i].distance < h[j].distance\n}\n\nfunc (h nodeHeap) Swap(i, j int) {\n    h[i], h[j] = h[j], h[i]\n}\n\nfunc (h *nodeHeap) Pop() interface{} {\n    tail := len(*h) - 1\n    x := (*h)[tail]\n    *h = (*h)[0:tail]\n    return x\n}\n\nfunc (h *nodeHeap) Push(x interface{}) {\n    *h = append(*h, x.(*node))\n}\n\n// 4 个方向\nvar direct = [4][2]int{\n    {0, 1},\n    {0, -1},\n    {1, 0},\n    {-1, 0},\n}\n\nfunc max(x, y int) int {\n    if x > y {\n        return x\n    }\n    return y\n}\n\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n\nfunc minimumEffortPath(heights [][]int) int {\n    const infinity = 10000000\n    m, n := len(heights), len(heights[0])\n\n    maxDis := make([][]int, m)\n    for i:=0;i<m;i++{\n        maxDis[i] = make([]int, n)\n        for j:=0;j<n;j++{\n            maxDis[i][j] = infinity\n        }\n    }\n\n    nh := &nodeHeap{{\n        x: 0,\n        y: 0,\n    }}\n    heap.Init(nh)\n    for {\n        p := heap.Pop(nh).(*node)\n        if p.x == m-1 && p.y == n-1 {\n            return p.distance\n        }\n        for _, d := range direct {\n            x, y := p.x + d[0], p.y + d[1]\n            if x >= 0 && x < m && y >= 0 && y < n {\n                d := max(p.distance, abs(heights[p.x][p.y] - heights[x][y]))\n                if d < maxDis[x][y] {\n                    maxDis[x][y] = d\n                    heap.Push(nh, &node{\n                        x: x,\n                        y: y,\n                        distance: d,\n                    })\n                }\n            }\n        }\n    }\n\n    return 0\n}\n```\n","source":"_posts/go-标准库源码-heap.md","raw":"---\ntitle: go 标准库的 heap\ndate: 2021-01-31 22:05:38\ntags: [golang, 源码, 堆]\ncategories: golang\n---\n\ngo 标准库提供的 [堆](https://en.wikipedia.org/wiki/Heap_(data_structure)) 虽然在 [`container`](https://github.com/golang/go/tree/master/src/container/heap) 包里，但它其实并没有像 `list` 和 `ring` 那样提供一个实实在在的容器，事实上它定义了一个如下的接口和一系列堆的基本操作，只要是实现了该接口的结构就可以被认为是一个堆，从而把堆的操作方法用到该结构上。\n\n```go\ntype Interface interface {\n    // 排序接口\n    sort.Interface\n    // 追加元素\n    Push(x interface{})\n    // 移除首个元素\n    Pop() interface{}\n}\n```\n\n**注意** `Interface` 中的 `Push` 和 `Pop` 方法是针对要实现该接口的数据接口本身的追加和移除操作，并非我们通常说的堆的 `Push` 和 `Pop` 方法，在使用堆时切记使用的是 `heap.Push(h, x)` 和 `heap.Pop(h)` 。\n\n## 堆的初始化\n\n```go\n// 把给定的结构初始化成一个 最小堆\nfunc Init(h Interface) {\n    n := h.Len()\n    // i = n / 2 - 1\n    // 2i + 1 = n - 1 => i 是 非叶子节点\n    // 对所有非叶子节点进行下沉操作\n    for i := n/2 - 1; i >= 0; i-- {\n        down(h, i, n)\n    }\n}\n\n// 节点下沉操作\n// n: 下沉操作的界限\nfunc down(h Interface, i0, n int) bool {\n    i := i0\n    for {\n        j1 := 2*i + 1\n        // 下沉是考虑的节点不超过 n\n        // 可以观察下 Init/Fix 和 Pop/Remove 时 n 的值\n        if j1 >= n || j1 < 0 { // j1 < 0 after int overflow\n            break\n        }\n        j := j1 // left child\n        // 选出左、右子节点中较小的\n        if j2 := j1 + 1; j2 < n && h.Less(j2, j1) {\n            j = j2 // = 2*i + 2  // right child\n        }\n        if !h.Less(j, i) {\n            // 子节点不小于父节点 (已经是有序的)\n            break\n        }\n        // 父节点与左、右子节点中较小的进行交换\n        h.Swap(i, j)\n        // 原来的父节点已经变为子节点，考虑是否还要继续下沉\n        i = j\n    }\n    // 返回 i0 节点是否下沉了\n    return i > i0\n}\n```\n\n## 插入元素\n\n```go\nfunc Push(h Interface, x interface{}) {\n    h.Push(x)\n    // 添加的元素是堆对应二叉树的最右下的节点\n    // 考虑该元素是否需要上浮\n    up(h, h.Len()-1)\n}\n\n// 元素上浮操作\nfunc up(h Interface, j int) {\n    for {\n        i := (j - 1) / 2 // parent\n        if i == j || !h.Less(j, i) {\n            // 该元素不小于父节点\n            break\n        }\n        // 与父节点交换\n        h.Swap(i, j)\n        // 考虑是否需要继续上浮\n        j = i\n    }\n}\n```\n\n## 弹出元素与移除某个元素\n\n```go\n// 移除堆的根节点\nfunc Pop(h Interface) interface{} {\n    n := h.Len() - 1\n    // 根节点与最后一个（最右下）元素交换\n    h.Swap(0, n)\n    // 对交换后的根节点进行下沉操作\n    // 注意下沉时的界限为 倒数第二个 元素 （不包括最后一个元素，否则就白交换了）\n    down(h, 0, n)\n    // 移除最后一个元素，即原来的根节点\n    return h.Pop()\n}\n\n// 移除堆的第 n 个节点\nfunc Remove(h Interface, i int) interface{} {\n    n := h.Len() - 1\n    // 如果是最后一个节点的话直接移除\n    if n != i {\n        h.Swap(i, n)\n        if !down(h, i, n) {\n            // 交换、下沉与 Pop 类似\n            // 因为 i 不一定是根节点，如果有下沉操作的话还要考虑是否要进行上浮\n            up(h, i)\n        }\n    }\n    return h.Pop()\n}\n```\n\n## 修复\n\n```go\n// 节点 i 的值发生变化后需要对堆进行修复\nfunc Fix(h Interface, i int) {\n    // 先下沉\n    if !down(h, i, h.Len()) {\n        // 如果有下沉操作则考虑上浮\n        up(h, i)\n    }\n}\n```\n\n## 使用示例\n\n使用堆实现 [Dijkstra's algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) 来解决 [Leetcode 1631. 最小体力消耗路径](https://leetcode-cn.com/problems/path-with-minimum-effort/) 问题：\n\n```go\ntype node struct {\n    x, y, distance int\n}\n\n// 定义堆\ntype nodeHeap []*node\n\nfunc (h nodeHeap) Len() int {\n    return len(h)\n}\n\nfunc (h nodeHeap) Less(i, j int) bool {\n    return h[i].distance < h[j].distance\n}\n\nfunc (h nodeHeap) Swap(i, j int) {\n    h[i], h[j] = h[j], h[i]\n}\n\nfunc (h *nodeHeap) Pop() interface{} {\n    tail := len(*h) - 1\n    x := (*h)[tail]\n    *h = (*h)[0:tail]\n    return x\n}\n\nfunc (h *nodeHeap) Push(x interface{}) {\n    *h = append(*h, x.(*node))\n}\n\n// 4 个方向\nvar direct = [4][2]int{\n    {0, 1},\n    {0, -1},\n    {1, 0},\n    {-1, 0},\n}\n\nfunc max(x, y int) int {\n    if x > y {\n        return x\n    }\n    return y\n}\n\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n\nfunc minimumEffortPath(heights [][]int) int {\n    const infinity = 10000000\n    m, n := len(heights), len(heights[0])\n\n    maxDis := make([][]int, m)\n    for i:=0;i<m;i++{\n        maxDis[i] = make([]int, n)\n        for j:=0;j<n;j++{\n            maxDis[i][j] = infinity\n        }\n    }\n\n    nh := &nodeHeap{{\n        x: 0,\n        y: 0,\n    }}\n    heap.Init(nh)\n    for {\n        p := heap.Pop(nh).(*node)\n        if p.x == m-1 && p.y == n-1 {\n            return p.distance\n        }\n        for _, d := range direct {\n            x, y := p.x + d[0], p.y + d[1]\n            if x >= 0 && x < m && y >= 0 && y < n {\n                d := max(p.distance, abs(heights[p.x][p.y] - heights[x][y]))\n                if d < maxDis[x][y] {\n                    maxDis[x][y] = d\n                    heap.Push(nh, &node{\n                        x: x,\n                        y: y,\n                        distance: d,\n                    })\n                }\n            }\n        }\n    }\n\n    return 0\n}\n```\n","slug":"go-标准库源码-heap","published":1,"updated":"2021-01-31T15:56:39.998Z","_id":"ckklbag4v0000z5fy5t9qbekm","comments":1,"layout":"post","photos":[],"link":"","content":"<p>go 标准库提供的 <a href=\"https://en.wikipedia.org/wiki/Heap_(data_structure)\">堆</a> 虽然在 <a href=\"https://github.com/golang/go/tree/master/src/container/heap\"><code>container</code></a> 包里，但它其实并没有像 <code>list</code> 和 <code>ring</code> 那样提供一个实实在在的容器，事实上它定义了一个如下的接口和一系列堆的基本操作，只要是实现了该接口的结构就可以被认为是一个堆，从而把堆的操作方法用到该结构上。</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> Interface <span class=\"hljs-keyword\">interface</span> &#123;\n    <span class=\"hljs-comment\">// 排序接口</span>\n    sort.Interface\n    <span class=\"hljs-comment\">// 追加元素</span>\n    Push(x <span class=\"hljs-keyword\">interface</span>&#123;&#125;)\n    <span class=\"hljs-comment\">// 移除首个元素</span>\n    Pop() <span class=\"hljs-keyword\">interface</span>&#123;&#125;\n&#125;</code></pre>\n\n<p><strong>注意</strong> <code>Interface</code> 中的 <code>Push</code> 和 <code>Pop</code> 方法是针对要实现该接口的数据接口本身的追加和移除操作，并非我们通常说的堆的 <code>Push</code> 和 <code>Pop</code> 方法，在使用堆时切记使用的是 <code>heap.Push(h, x)</code> 和 <code>heap.Pop(h)</code> 。</p>\n<h2 id=\"堆的初始化\"><a href=\"#堆的初始化\" class=\"headerlink\" title=\"堆的初始化\"></a>堆的初始化</h2><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 把给定的结构初始化成一个 最小堆</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Init</span><span class=\"hljs-params\">(h Interface)</span></span> &#123;\n    n := h.Len()\n    <span class=\"hljs-comment\">// i = n / 2 - 1</span>\n    <span class=\"hljs-comment\">// 2i + 1 = n - 1 =&gt; i 是 非叶子节点</span>\n    <span class=\"hljs-comment\">// 对所有非叶子节点进行下沉操作</span>\n    <span class=\"hljs-keyword\">for</span> i := n/<span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i-- &#123;\n        down(h, i, n)\n    &#125;\n&#125;\n\n<span class=\"hljs-comment\">// 节点下沉操作</span>\n<span class=\"hljs-comment\">// n: 下沉操作的界限</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">down</span><span class=\"hljs-params\">(h Interface, i0, n <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">bool</span></span> &#123;\n    i := i0\n    <span class=\"hljs-keyword\">for</span> &#123;\n        j1 := <span class=\"hljs-number\">2</span>*i + <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-comment\">// 下沉是考虑的节点不超过 n</span>\n        <span class=\"hljs-comment\">// 可以观察下 Init/Fix 和 Pop/Remove 时 n 的值</span>\n        <span class=\"hljs-keyword\">if</span> j1 &gt;= n || j1 &lt; <span class=\"hljs-number\">0</span> &#123; <span class=\"hljs-comment\">// j1 &lt; 0 after int overflow</span>\n            <span class=\"hljs-keyword\">break</span>\n        &#125;\n        j := j1 <span class=\"hljs-comment\">// left child</span>\n        <span class=\"hljs-comment\">// 选出左、右子节点中较小的</span>\n        <span class=\"hljs-keyword\">if</span> j2 := j1 + <span class=\"hljs-number\">1</span>; j2 &lt; n &amp;&amp; h.Less(j2, j1) &#123;\n            j = j2 <span class=\"hljs-comment\">// = 2*i + 2  // right child</span>\n        &#125;\n        <span class=\"hljs-keyword\">if</span> !h.Less(j, i) &#123;\n            <span class=\"hljs-comment\">// 子节点不小于父节点 (已经是有序的)</span>\n            <span class=\"hljs-keyword\">break</span>\n        &#125;\n        <span class=\"hljs-comment\">// 父节点与左、右子节点中较小的进行交换</span>\n        h.Swap(i, j)\n        <span class=\"hljs-comment\">// 原来的父节点已经变为子节点，考虑是否还要继续下沉</span>\n        i = j\n    &#125;\n    <span class=\"hljs-comment\">// 返回 i0 节点是否下沉了</span>\n    <span class=\"hljs-keyword\">return</span> i &gt; i0\n&#125;</code></pre>\n\n<h2 id=\"插入元素\"><a href=\"#插入元素\" class=\"headerlink\" title=\"插入元素\"></a>插入元素</h2><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Push</span><span class=\"hljs-params\">(h Interface, x <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span></span> &#123;\n    h.Push(x)\n    <span class=\"hljs-comment\">// 添加的元素是堆对应二叉树的最右下的节点</span>\n    <span class=\"hljs-comment\">// 考虑该元素是否需要上浮</span>\n    up(h, h.Len()<span class=\"hljs-number\">-1</span>)\n&#125;\n\n<span class=\"hljs-comment\">// 元素上浮操作</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">up</span><span class=\"hljs-params\">(h Interface, j <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n    <span class=\"hljs-keyword\">for</span> &#123;\n        i := (j - <span class=\"hljs-number\">1</span>) / <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">// parent</span>\n        <span class=\"hljs-keyword\">if</span> i == j || !h.Less(j, i) &#123;\n            <span class=\"hljs-comment\">// 该元素不小于父节点</span>\n            <span class=\"hljs-keyword\">break</span>\n        &#125;\n        <span class=\"hljs-comment\">// 与父节点交换</span>\n        h.Swap(i, j)\n        <span class=\"hljs-comment\">// 考虑是否需要继续上浮</span>\n        j = i\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"弹出元素与移除某个元素\"><a href=\"#弹出元素与移除某个元素\" class=\"headerlink\" title=\"弹出元素与移除某个元素\"></a>弹出元素与移除某个元素</h2><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 移除堆的根节点</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Pop</span><span class=\"hljs-params\">(h Interface)</span> <span class=\"hljs-title\">interface</span></span>&#123;&#125; &#123;\n    n := h.Len() - <span class=\"hljs-number\">1</span>\n    <span class=\"hljs-comment\">// 根节点与最后一个（最右下）元素交换</span>\n    h.Swap(<span class=\"hljs-number\">0</span>, n)\n    <span class=\"hljs-comment\">// 对交换后的根节点进行下沉操作</span>\n    <span class=\"hljs-comment\">// 注意下沉时的界限为 倒数第二个 元素 （不包括最后一个元素，否则就白交换了）</span>\n    down(h, <span class=\"hljs-number\">0</span>, n)\n    <span class=\"hljs-comment\">// 移除最后一个元素，即原来的根节点</span>\n    <span class=\"hljs-keyword\">return</span> h.Pop()\n&#125;\n\n<span class=\"hljs-comment\">// 移除堆的第 n 个节点</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Remove</span><span class=\"hljs-params\">(h Interface, i <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">interface</span></span>&#123;&#125; &#123;\n    n := h.Len() - <span class=\"hljs-number\">1</span>\n    <span class=\"hljs-comment\">// 如果是最后一个节点的话直接移除</span>\n    <span class=\"hljs-keyword\">if</span> n != i &#123;\n        h.Swap(i, n)\n        <span class=\"hljs-keyword\">if</span> !down(h, i, n) &#123;\n            <span class=\"hljs-comment\">// 交换、下沉与 Pop 类似</span>\n            <span class=\"hljs-comment\">// 因为 i 不一定是根节点，如果有下沉操作的话还要考虑是否要进行上浮</span>\n            up(h, i)\n        &#125;\n    &#125;\n    <span class=\"hljs-keyword\">return</span> h.Pop()\n&#125;</code></pre>\n\n<h2 id=\"修复\"><a href=\"#修复\" class=\"headerlink\" title=\"修复\"></a>修复</h2><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 节点 i 的值发生变化后需要对堆进行修复</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Fix</span><span class=\"hljs-params\">(h Interface, i <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n    <span class=\"hljs-comment\">// 先下沉</span>\n    <span class=\"hljs-keyword\">if</span> !down(h, i, h.Len()) &#123;\n        <span class=\"hljs-comment\">// 如果有下沉操作则考虑上浮</span>\n        up(h, i)\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"使用示例\"><a href=\"#使用示例\" class=\"headerlink\" title=\"使用示例\"></a>使用示例</h2><p>使用堆实现 <a href=\"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\">Dijkstra’s algorithm</a> 来解决 <a href=\"https://leetcode-cn.com/problems/path-with-minimum-effort/\">Leetcode 1631. 最小体力消耗路径</a> 问题：</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> node <span class=\"hljs-keyword\">struct</span> &#123;\n    x, y, distance <span class=\"hljs-keyword\">int</span>\n&#125;\n\n<span class=\"hljs-comment\">// 定义堆</span>\n<span class=\"hljs-keyword\">type</span> nodeHeap []*node\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(h nodeHeap)</span> <span class=\"hljs-title\">Len</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">int</span></span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(h)\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(h nodeHeap)</span> <span class=\"hljs-title\">Less</span><span class=\"hljs-params\">(i, j <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">bool</span></span> &#123;\n    <span class=\"hljs-keyword\">return</span> h[i].distance &lt; h[j].distance\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(h nodeHeap)</span> <span class=\"hljs-title\">Swap</span><span class=\"hljs-params\">(i, j <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n    h[i], h[j] = h[j], h[i]\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(h *nodeHeap)</span> <span class=\"hljs-title\">Pop</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">interface</span></span>&#123;&#125; &#123;\n    tail := <span class=\"hljs-built_in\">len</span>(*h) - <span class=\"hljs-number\">1</span>\n    x := (*h)[tail]\n    *h = (*h)[<span class=\"hljs-number\">0</span>:tail]\n    <span class=\"hljs-keyword\">return</span> x\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(h *nodeHeap)</span> <span class=\"hljs-title\">Push</span><span class=\"hljs-params\">(x <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span></span> &#123;\n    *h = <span class=\"hljs-built_in\">append</span>(*h, x.(*node))\n&#125;\n\n<span class=\"hljs-comment\">// 4 个方向</span>\n<span class=\"hljs-keyword\">var</span> direct = [<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">2</span>]<span class=\"hljs-keyword\">int</span>&#123;\n    &#123;<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>&#125;,\n    &#123;<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>&#125;,\n    &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>&#125;,\n    &#123;<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">0</span>&#125;,\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">max</span><span class=\"hljs-params\">(x, y <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">int</span></span> &#123;\n    <span class=\"hljs-keyword\">if</span> x &gt; y &#123;\n        <span class=\"hljs-keyword\">return</span> x\n    &#125;\n    <span class=\"hljs-keyword\">return</span> y\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">abs</span><span class=\"hljs-params\">(x <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">int</span></span> &#123;\n    <span class=\"hljs-keyword\">if</span> x &lt; <span class=\"hljs-number\">0</span> &#123;\n        <span class=\"hljs-keyword\">return</span> -x\n    &#125;\n    <span class=\"hljs-keyword\">return</span> x\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">minimumEffortPath</span><span class=\"hljs-params\">(heights [][]<span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">int</span></span> &#123;\n    <span class=\"hljs-keyword\">const</span> infinity = <span class=\"hljs-number\">10000000</span>\n    m, n := <span class=\"hljs-built_in\">len</span>(heights), <span class=\"hljs-built_in\">len</span>(heights[<span class=\"hljs-number\">0</span>])\n\n    maxDis := <span class=\"hljs-built_in\">make</span>([][]<span class=\"hljs-keyword\">int</span>, m)\n    <span class=\"hljs-keyword\">for</span> i:=<span class=\"hljs-number\">0</span>;i&lt;m;i++&#123;\n        maxDis[i] = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">int</span>, n)\n        <span class=\"hljs-keyword\">for</span> j:=<span class=\"hljs-number\">0</span>;j&lt;n;j++&#123;\n            maxDis[i][j] = infinity\n        &#125;\n    &#125;\n\n    nh := &amp;nodeHeap&#123;&#123;\n        x: <span class=\"hljs-number\">0</span>,\n        y: <span class=\"hljs-number\">0</span>,\n    &#125;&#125;\n    heap.Init(nh)\n    <span class=\"hljs-keyword\">for</span> &#123;\n        p := heap.Pop(nh).(*node)\n        <span class=\"hljs-keyword\">if</span> p.x == m<span class=\"hljs-number\">-1</span> &amp;&amp; p.y == n<span class=\"hljs-number\">-1</span> &#123;\n            <span class=\"hljs-keyword\">return</span> p.distance\n        &#125;\n        <span class=\"hljs-keyword\">for</span> _, d := <span class=\"hljs-keyword\">range</span> direct &#123;\n            x, y := p.x + d[<span class=\"hljs-number\">0</span>], p.y + d[<span class=\"hljs-number\">1</span>]\n            <span class=\"hljs-keyword\">if</span> x &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; y &lt; n &#123;\n                d := max(p.distance, abs(heights[p.x][p.y] - heights[x][y]))\n                <span class=\"hljs-keyword\">if</span> d &lt; maxDis[x][y] &#123;\n                    maxDis[x][y] = d\n                    heap.Push(nh, &amp;node&#123;\n                        x: x,\n                        y: y,\n                        distance: d,\n                    &#125;)\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>\n&#125;</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>go 标准库提供的 <a href=\"https://en.wikipedia.org/wiki/Heap_(data_structure)\">堆</a> 虽然在 <a href=\"https://github.com/golang/go/tree/master/src/container/heap\"><code>container</code></a> 包里，但它其实并没有像 <code>list</code> 和 <code>ring</code> 那样提供一个实实在在的容器，事实上它定义了一个如下的接口和一系列堆的基本操作，只要是实现了该接口的结构就可以被认为是一个堆，从而把堆的操作方法用到该结构上。</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> Interface <span class=\"hljs-keyword\">interface</span> &#123;\n    <span class=\"hljs-comment\">// 排序接口</span>\n    sort.Interface\n    <span class=\"hljs-comment\">// 追加元素</span>\n    Push(x <span class=\"hljs-keyword\">interface</span>&#123;&#125;)\n    <span class=\"hljs-comment\">// 移除首个元素</span>\n    Pop() <span class=\"hljs-keyword\">interface</span>&#123;&#125;\n&#125;</code></pre>\n\n<p><strong>注意</strong> <code>Interface</code> 中的 <code>Push</code> 和 <code>Pop</code> 方法是针对要实现该接口的数据接口本身的追加和移除操作，并非我们通常说的堆的 <code>Push</code> 和 <code>Pop</code> 方法，在使用堆时切记使用的是 <code>heap.Push(h, x)</code> 和 <code>heap.Pop(h)</code> 。</p>\n<h2 id=\"堆的初始化\"><a href=\"#堆的初始化\" class=\"headerlink\" title=\"堆的初始化\"></a>堆的初始化</h2><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 把给定的结构初始化成一个 最小堆</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Init</span><span class=\"hljs-params\">(h Interface)</span></span> &#123;\n    n := h.Len()\n    <span class=\"hljs-comment\">// i = n / 2 - 1</span>\n    <span class=\"hljs-comment\">// 2i + 1 = n - 1 =&gt; i 是 非叶子节点</span>\n    <span class=\"hljs-comment\">// 对所有非叶子节点进行下沉操作</span>\n    <span class=\"hljs-keyword\">for</span> i := n/<span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i-- &#123;\n        down(h, i, n)\n    &#125;\n&#125;\n\n<span class=\"hljs-comment\">// 节点下沉操作</span>\n<span class=\"hljs-comment\">// n: 下沉操作的界限</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">down</span><span class=\"hljs-params\">(h Interface, i0, n <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">bool</span></span> &#123;\n    i := i0\n    <span class=\"hljs-keyword\">for</span> &#123;\n        j1 := <span class=\"hljs-number\">2</span>*i + <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-comment\">// 下沉是考虑的节点不超过 n</span>\n        <span class=\"hljs-comment\">// 可以观察下 Init/Fix 和 Pop/Remove 时 n 的值</span>\n        <span class=\"hljs-keyword\">if</span> j1 &gt;= n || j1 &lt; <span class=\"hljs-number\">0</span> &#123; <span class=\"hljs-comment\">// j1 &lt; 0 after int overflow</span>\n            <span class=\"hljs-keyword\">break</span>\n        &#125;\n        j := j1 <span class=\"hljs-comment\">// left child</span>\n        <span class=\"hljs-comment\">// 选出左、右子节点中较小的</span>\n        <span class=\"hljs-keyword\">if</span> j2 := j1 + <span class=\"hljs-number\">1</span>; j2 &lt; n &amp;&amp; h.Less(j2, j1) &#123;\n            j = j2 <span class=\"hljs-comment\">// = 2*i + 2  // right child</span>\n        &#125;\n        <span class=\"hljs-keyword\">if</span> !h.Less(j, i) &#123;\n            <span class=\"hljs-comment\">// 子节点不小于父节点 (已经是有序的)</span>\n            <span class=\"hljs-keyword\">break</span>\n        &#125;\n        <span class=\"hljs-comment\">// 父节点与左、右子节点中较小的进行交换</span>\n        h.Swap(i, j)\n        <span class=\"hljs-comment\">// 原来的父节点已经变为子节点，考虑是否还要继续下沉</span>\n        i = j\n    &#125;\n    <span class=\"hljs-comment\">// 返回 i0 节点是否下沉了</span>\n    <span class=\"hljs-keyword\">return</span> i &gt; i0\n&#125;</code></pre>\n\n<h2 id=\"插入元素\"><a href=\"#插入元素\" class=\"headerlink\" title=\"插入元素\"></a>插入元素</h2><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Push</span><span class=\"hljs-params\">(h Interface, x <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span></span> &#123;\n    h.Push(x)\n    <span class=\"hljs-comment\">// 添加的元素是堆对应二叉树的最右下的节点</span>\n    <span class=\"hljs-comment\">// 考虑该元素是否需要上浮</span>\n    up(h, h.Len()<span class=\"hljs-number\">-1</span>)\n&#125;\n\n<span class=\"hljs-comment\">// 元素上浮操作</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">up</span><span class=\"hljs-params\">(h Interface, j <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n    <span class=\"hljs-keyword\">for</span> &#123;\n        i := (j - <span class=\"hljs-number\">1</span>) / <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">// parent</span>\n        <span class=\"hljs-keyword\">if</span> i == j || !h.Less(j, i) &#123;\n            <span class=\"hljs-comment\">// 该元素不小于父节点</span>\n            <span class=\"hljs-keyword\">break</span>\n        &#125;\n        <span class=\"hljs-comment\">// 与父节点交换</span>\n        h.Swap(i, j)\n        <span class=\"hljs-comment\">// 考虑是否需要继续上浮</span>\n        j = i\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"弹出元素与移除某个元素\"><a href=\"#弹出元素与移除某个元素\" class=\"headerlink\" title=\"弹出元素与移除某个元素\"></a>弹出元素与移除某个元素</h2><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 移除堆的根节点</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Pop</span><span class=\"hljs-params\">(h Interface)</span> <span class=\"hljs-title\">interface</span></span>&#123;&#125; &#123;\n    n := h.Len() - <span class=\"hljs-number\">1</span>\n    <span class=\"hljs-comment\">// 根节点与最后一个（最右下）元素交换</span>\n    h.Swap(<span class=\"hljs-number\">0</span>, n)\n    <span class=\"hljs-comment\">// 对交换后的根节点进行下沉操作</span>\n    <span class=\"hljs-comment\">// 注意下沉时的界限为 倒数第二个 元素 （不包括最后一个元素，否则就白交换了）</span>\n    down(h, <span class=\"hljs-number\">0</span>, n)\n    <span class=\"hljs-comment\">// 移除最后一个元素，即原来的根节点</span>\n    <span class=\"hljs-keyword\">return</span> h.Pop()\n&#125;\n\n<span class=\"hljs-comment\">// 移除堆的第 n 个节点</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Remove</span><span class=\"hljs-params\">(h Interface, i <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">interface</span></span>&#123;&#125; &#123;\n    n := h.Len() - <span class=\"hljs-number\">1</span>\n    <span class=\"hljs-comment\">// 如果是最后一个节点的话直接移除</span>\n    <span class=\"hljs-keyword\">if</span> n != i &#123;\n        h.Swap(i, n)\n        <span class=\"hljs-keyword\">if</span> !down(h, i, n) &#123;\n            <span class=\"hljs-comment\">// 交换、下沉与 Pop 类似</span>\n            <span class=\"hljs-comment\">// 因为 i 不一定是根节点，如果有下沉操作的话还要考虑是否要进行上浮</span>\n            up(h, i)\n        &#125;\n    &#125;\n    <span class=\"hljs-keyword\">return</span> h.Pop()\n&#125;</code></pre>\n\n<h2 id=\"修复\"><a href=\"#修复\" class=\"headerlink\" title=\"修复\"></a>修复</h2><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 节点 i 的值发生变化后需要对堆进行修复</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Fix</span><span class=\"hljs-params\">(h Interface, i <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n    <span class=\"hljs-comment\">// 先下沉</span>\n    <span class=\"hljs-keyword\">if</span> !down(h, i, h.Len()) &#123;\n        <span class=\"hljs-comment\">// 如果有下沉操作则考虑上浮</span>\n        up(h, i)\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"使用示例\"><a href=\"#使用示例\" class=\"headerlink\" title=\"使用示例\"></a>使用示例</h2><p>使用堆实现 <a href=\"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\">Dijkstra’s algorithm</a> 来解决 <a href=\"https://leetcode-cn.com/problems/path-with-minimum-effort/\">Leetcode 1631. 最小体力消耗路径</a> 问题：</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> node <span class=\"hljs-keyword\">struct</span> &#123;\n    x, y, distance <span class=\"hljs-keyword\">int</span>\n&#125;\n\n<span class=\"hljs-comment\">// 定义堆</span>\n<span class=\"hljs-keyword\">type</span> nodeHeap []*node\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(h nodeHeap)</span> <span class=\"hljs-title\">Len</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">int</span></span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(h)\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(h nodeHeap)</span> <span class=\"hljs-title\">Less</span><span class=\"hljs-params\">(i, j <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">bool</span></span> &#123;\n    <span class=\"hljs-keyword\">return</span> h[i].distance &lt; h[j].distance\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(h nodeHeap)</span> <span class=\"hljs-title\">Swap</span><span class=\"hljs-params\">(i, j <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n    h[i], h[j] = h[j], h[i]\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(h *nodeHeap)</span> <span class=\"hljs-title\">Pop</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">interface</span></span>&#123;&#125; &#123;\n    tail := <span class=\"hljs-built_in\">len</span>(*h) - <span class=\"hljs-number\">1</span>\n    x := (*h)[tail]\n    *h = (*h)[<span class=\"hljs-number\">0</span>:tail]\n    <span class=\"hljs-keyword\">return</span> x\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(h *nodeHeap)</span> <span class=\"hljs-title\">Push</span><span class=\"hljs-params\">(x <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span></span> &#123;\n    *h = <span class=\"hljs-built_in\">append</span>(*h, x.(*node))\n&#125;\n\n<span class=\"hljs-comment\">// 4 个方向</span>\n<span class=\"hljs-keyword\">var</span> direct = [<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">2</span>]<span class=\"hljs-keyword\">int</span>&#123;\n    &#123;<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>&#125;,\n    &#123;<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>&#125;,\n    &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>&#125;,\n    &#123;<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">0</span>&#125;,\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">max</span><span class=\"hljs-params\">(x, y <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">int</span></span> &#123;\n    <span class=\"hljs-keyword\">if</span> x &gt; y &#123;\n        <span class=\"hljs-keyword\">return</span> x\n    &#125;\n    <span class=\"hljs-keyword\">return</span> y\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">abs</span><span class=\"hljs-params\">(x <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">int</span></span> &#123;\n    <span class=\"hljs-keyword\">if</span> x &lt; <span class=\"hljs-number\">0</span> &#123;\n        <span class=\"hljs-keyword\">return</span> -x\n    &#125;\n    <span class=\"hljs-keyword\">return</span> x\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">minimumEffortPath</span><span class=\"hljs-params\">(heights [][]<span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">int</span></span> &#123;\n    <span class=\"hljs-keyword\">const</span> infinity = <span class=\"hljs-number\">10000000</span>\n    m, n := <span class=\"hljs-built_in\">len</span>(heights), <span class=\"hljs-built_in\">len</span>(heights[<span class=\"hljs-number\">0</span>])\n\n    maxDis := <span class=\"hljs-built_in\">make</span>([][]<span class=\"hljs-keyword\">int</span>, m)\n    <span class=\"hljs-keyword\">for</span> i:=<span class=\"hljs-number\">0</span>;i&lt;m;i++&#123;\n        maxDis[i] = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">int</span>, n)\n        <span class=\"hljs-keyword\">for</span> j:=<span class=\"hljs-number\">0</span>;j&lt;n;j++&#123;\n            maxDis[i][j] = infinity\n        &#125;\n    &#125;\n\n    nh := &amp;nodeHeap&#123;&#123;\n        x: <span class=\"hljs-number\">0</span>,\n        y: <span class=\"hljs-number\">0</span>,\n    &#125;&#125;\n    heap.Init(nh)\n    <span class=\"hljs-keyword\">for</span> &#123;\n        p := heap.Pop(nh).(*node)\n        <span class=\"hljs-keyword\">if</span> p.x == m<span class=\"hljs-number\">-1</span> &amp;&amp; p.y == n<span class=\"hljs-number\">-1</span> &#123;\n            <span class=\"hljs-keyword\">return</span> p.distance\n        &#125;\n        <span class=\"hljs-keyword\">for</span> _, d := <span class=\"hljs-keyword\">range</span> direct &#123;\n            x, y := p.x + d[<span class=\"hljs-number\">0</span>], p.y + d[<span class=\"hljs-number\">1</span>]\n            <span class=\"hljs-keyword\">if</span> x &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; y &lt; n &#123;\n                d := max(p.distance, abs(heights[p.x][p.y] - heights[x][y]))\n                <span class=\"hljs-keyword\">if</span> d &lt; maxDis[x][y] &#123;\n                    maxDis[x][y] = d\n                    heap.Push(nh, &amp;node&#123;\n                        x: x,\n                        y: y,\n                        distance: d,\n                    &#125;)\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>\n&#125;</code></pre>\n"},{"title":"sync.Map 源码阅读","date":"2021-01-28T15:57:04.000Z","_content":"\n## 数据结构\n\n### Map\n\n```go\ntype Map struct {\n    mu Mutex\n    // 用于只读的快照\n    read atomic.Value\n    // 存储键值对\n    dirty map[interface{}]*entry\n\n    misses int\n}\n```\n\n### readOnly\n\n```go\n// Map 结构中 read 字段存储的数据的结构\ntype readOnly struct {\n    // 存储键值对的 map\n    m       map[interface{}]*entry\n    // 标记 m 是否完整包含了 Map 中的所有键值对\n    //   true: 不完整, 即 dirty 中有些 key 在 read 中是没有的\n    //   fasle: 完整, 即 dirty 中所有的 key 在 read 中也都存在\n    amended bool // true if the dirty map contains some key not in m.\n}\n```\n\n### entry\n\n\n```go\n// 存储键值对值的数据结构\ntype entry struct {\n    // p 指向键值对的值\n    // 如果键值对被删除则 p 指向 expunged\n    p unsafe.Pointer\n}\n```\n\n### expunged\n\n```go\n// 用于标记某个 entry 是否被删除\n// sync.Map 删除一个键值对时不会直接进行物理删除\n// 而是先将其对应的 entry 中的 p 指针射中为 expunged\nvar expunged = unsafe.Pointer(new(interface{}))\n```\n\n## Store\n\n","source":"_posts/sync-Map-源码阅读.md","raw":"---\ntitle: sync.Map 源码阅读\ndate: 2021-01-28 23:57:04\ntags: [golang, 源码, 并发编程]\ncategories: golang\n---\n\n## 数据结构\n\n### Map\n\n```go\ntype Map struct {\n    mu Mutex\n    // 用于只读的快照\n    read atomic.Value\n    // 存储键值对\n    dirty map[interface{}]*entry\n\n    misses int\n}\n```\n\n### readOnly\n\n```go\n// Map 结构中 read 字段存储的数据的结构\ntype readOnly struct {\n    // 存储键值对的 map\n    m       map[interface{}]*entry\n    // 标记 m 是否完整包含了 Map 中的所有键值对\n    //   true: 不完整, 即 dirty 中有些 key 在 read 中是没有的\n    //   fasle: 完整, 即 dirty 中所有的 key 在 read 中也都存在\n    amended bool // true if the dirty map contains some key not in m.\n}\n```\n\n### entry\n\n\n```go\n// 存储键值对值的数据结构\ntype entry struct {\n    // p 指向键值对的值\n    // 如果键值对被删除则 p 指向 expunged\n    p unsafe.Pointer\n}\n```\n\n### expunged\n\n```go\n// 用于标记某个 entry 是否被删除\n// sync.Map 删除一个键值对时不会直接进行物理删除\n// 而是先将其对应的 entry 中的 p 指针射中为 expunged\nvar expunged = unsafe.Pointer(new(interface{}))\n```\n\n## Store\n\n","slug":"sync-Map-源码阅读","published":1,"updated":"2021-01-28T16:12:39.364Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckklbag4x0001z5fyb71d19ob","content":"<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> Map <span class=\"hljs-keyword\">struct</span> &#123;\n    mu Mutex\n    <span class=\"hljs-comment\">// 用于只读的快照</span>\n    read atomic.Value\n    <span class=\"hljs-comment\">// 存储键值对</span>\n    dirty <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">interface</span>&#123;&#125;]*entry\n\n    misses <span class=\"hljs-keyword\">int</span>\n&#125;</code></pre>\n\n<h3 id=\"readOnly\"><a href=\"#readOnly\" class=\"headerlink\" title=\"readOnly\"></a>readOnly</h3><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// Map 结构中 read 字段存储的数据的结构</span>\n<span class=\"hljs-keyword\">type</span> readOnly <span class=\"hljs-keyword\">struct</span> &#123;\n    <span class=\"hljs-comment\">// 存储键值对的 map</span>\n    m       <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">interface</span>&#123;&#125;]*entry\n    <span class=\"hljs-comment\">// 标记 m 是否完整包含了 Map 中的所有键值对</span>\n    <span class=\"hljs-comment\">//   true: 不完整, 即 dirty 中有些 key 在 read 中是没有的</span>\n    <span class=\"hljs-comment\">//   fasle: 完整, 即 dirty 中所有的 key 在 read 中也都存在</span>\n    amended <span class=\"hljs-keyword\">bool</span> <span class=\"hljs-comment\">// true if the dirty map contains some key not in m.</span>\n&#125;</code></pre>\n\n<h3 id=\"entry\"><a href=\"#entry\" class=\"headerlink\" title=\"entry\"></a>entry</h3><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 存储键值对值的数据结构</span>\n<span class=\"hljs-keyword\">type</span> entry <span class=\"hljs-keyword\">struct</span> &#123;\n    <span class=\"hljs-comment\">// p 指向键值对的值</span>\n    <span class=\"hljs-comment\">// 如果键值对被删除则 p 指向 expunged</span>\n    p unsafe.Pointer\n&#125;</code></pre>\n\n<h3 id=\"expunged\"><a href=\"#expunged\" class=\"headerlink\" title=\"expunged\"></a>expunged</h3><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 用于标记某个 entry 是否被删除</span>\n<span class=\"hljs-comment\">// sync.Map 删除一个键值对时不会直接进行物理删除</span>\n<span class=\"hljs-comment\">// 而是先将其对应的 entry 中的 p 指针射中为 expunged</span>\n<span class=\"hljs-keyword\">var</span> expunged = unsafe.Pointer(<span class=\"hljs-built_in\">new</span>(<span class=\"hljs-keyword\">interface</span>&#123;&#125;))</code></pre>\n\n<h2 id=\"Store\"><a href=\"#Store\" class=\"headerlink\" title=\"Store\"></a>Store</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> Map <span class=\"hljs-keyword\">struct</span> &#123;\n    mu Mutex\n    <span class=\"hljs-comment\">// 用于只读的快照</span>\n    read atomic.Value\n    <span class=\"hljs-comment\">// 存储键值对</span>\n    dirty <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">interface</span>&#123;&#125;]*entry\n\n    misses <span class=\"hljs-keyword\">int</span>\n&#125;</code></pre>\n\n<h3 id=\"readOnly\"><a href=\"#readOnly\" class=\"headerlink\" title=\"readOnly\"></a>readOnly</h3><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// Map 结构中 read 字段存储的数据的结构</span>\n<span class=\"hljs-keyword\">type</span> readOnly <span class=\"hljs-keyword\">struct</span> &#123;\n    <span class=\"hljs-comment\">// 存储键值对的 map</span>\n    m       <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">interface</span>&#123;&#125;]*entry\n    <span class=\"hljs-comment\">// 标记 m 是否完整包含了 Map 中的所有键值对</span>\n    <span class=\"hljs-comment\">//   true: 不完整, 即 dirty 中有些 key 在 read 中是没有的</span>\n    <span class=\"hljs-comment\">//   fasle: 完整, 即 dirty 中所有的 key 在 read 中也都存在</span>\n    amended <span class=\"hljs-keyword\">bool</span> <span class=\"hljs-comment\">// true if the dirty map contains some key not in m.</span>\n&#125;</code></pre>\n\n<h3 id=\"entry\"><a href=\"#entry\" class=\"headerlink\" title=\"entry\"></a>entry</h3><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 存储键值对值的数据结构</span>\n<span class=\"hljs-keyword\">type</span> entry <span class=\"hljs-keyword\">struct</span> &#123;\n    <span class=\"hljs-comment\">// p 指向键值对的值</span>\n    <span class=\"hljs-comment\">// 如果键值对被删除则 p 指向 expunged</span>\n    p unsafe.Pointer\n&#125;</code></pre>\n\n<h3 id=\"expunged\"><a href=\"#expunged\" class=\"headerlink\" title=\"expunged\"></a>expunged</h3><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 用于标记某个 entry 是否被删除</span>\n<span class=\"hljs-comment\">// sync.Map 删除一个键值对时不会直接进行物理删除</span>\n<span class=\"hljs-comment\">// 而是先将其对应的 entry 中的 p 指针射中为 expunged</span>\n<span class=\"hljs-keyword\">var</span> expunged = unsafe.Pointer(<span class=\"hljs-built_in\">new</span>(<span class=\"hljs-keyword\">interface</span>&#123;&#125;))</code></pre>\n\n<h2 id=\"Store\"><a href=\"#Store\" class=\"headerlink\" title=\"Store\"></a>Store</h2>"},{"title":"sync.Once中的快速路径","date":"2021-01-24T16:23:27.000Z","_content":"\n`sync.Once` 的 [`Do`](https://github.com/golang/go/blob/b634f5d97a6e65f19057c00ed2095a1a872c7fa8/src/sync/once.go#L42) 方法中有这样一个技巧：先用原子操作 **快速** 判断是否执行过, 如果没有执行过（`done == 0`）再加锁执行 `f` 方法。\n\n``` Go\nfunc (o *Once) Do(f func()) {\n    if atomic.LoadUint32(&o.done) == 0 {\n        o.doSlow(f)\n    }\n}\n\nfunc (o *Once) doSlow(f func()) {\n    o.m.Lock()\n    defer o.m.Unlock()\n    if o.done == 0 {\n        defer atomic.StoreUint32(&o.done, 1)\n        f()\n    }\n}\n```\n\n其实这里完全可以直接执行 `doSlow` 方法，因为它内部已经加锁了，即便有并发执行也不会有任何问题。\n\n``` Go\nfunc (o *Once) Do(f func()) {\n    o.m.Lock()\n    defer o.m.Unlock()\n    if o.done == 0 {\n        defer atomic.StoreUint32(&o.done, 1)\n        f()\n    }\n}\n```\n\n之所以要多此一举是因为 **原子操作的性能要优于加锁** ，对于 `Do` 方法来说，大部分调用 `done` 都是不等于 0 的，因此这样做避免了对大部分的调用进行加锁判断（只有最初的 **一次或几次并发调用** 会进入到 `doSlow` 方法），是一种非常经典的编程范式。\n","source":"_posts/sync-Once中的快速路径.md","raw":"---\ntitle: sync.Once中的快速路径\ndate: 2021-01-25 00:23:27\ntags: [golang, 源码, 编程范式]\ncategories: golang\n---\n\n`sync.Once` 的 [`Do`](https://github.com/golang/go/blob/b634f5d97a6e65f19057c00ed2095a1a872c7fa8/src/sync/once.go#L42) 方法中有这样一个技巧：先用原子操作 **快速** 判断是否执行过, 如果没有执行过（`done == 0`）再加锁执行 `f` 方法。\n\n``` Go\nfunc (o *Once) Do(f func()) {\n    if atomic.LoadUint32(&o.done) == 0 {\n        o.doSlow(f)\n    }\n}\n\nfunc (o *Once) doSlow(f func()) {\n    o.m.Lock()\n    defer o.m.Unlock()\n    if o.done == 0 {\n        defer atomic.StoreUint32(&o.done, 1)\n        f()\n    }\n}\n```\n\n其实这里完全可以直接执行 `doSlow` 方法，因为它内部已经加锁了，即便有并发执行也不会有任何问题。\n\n``` Go\nfunc (o *Once) Do(f func()) {\n    o.m.Lock()\n    defer o.m.Unlock()\n    if o.done == 0 {\n        defer atomic.StoreUint32(&o.done, 1)\n        f()\n    }\n}\n```\n\n之所以要多此一举是因为 **原子操作的性能要优于加锁** ，对于 `Do` 方法来说，大部分调用 `done` 都是不等于 0 的，因此这样做避免了对大部分的调用进行加锁判断（只有最初的 **一次或几次并发调用** 会进入到 `doSlow` 方法），是一种非常经典的编程范式。\n","slug":"sync-Once中的快速路径","published":1,"updated":"2021-01-24T16:41:00.091Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckklbag53000gz5fybqzb9yz9","content":"<p><code>sync.Once</code> 的 <a href=\"https://github.com/golang/go/blob/b634f5d97a6e65f19057c00ed2095a1a872c7fa8/src/sync/once.go#L42\"><code>Do</code></a> 方法中有这样一个技巧：先用原子操作 <strong>快速</strong> 判断是否执行过, 如果没有执行过（<code>done == 0</code>）再加锁执行 <code>f</code> 方法。</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(o *Once)</span> <span class=\"hljs-title\">Do</span><span class=\"hljs-params\">(f <span class=\"hljs-keyword\">func</span>()</span>)</span> &#123;\n    <span class=\"hljs-keyword\">if</span> atomic.LoadUint32(&amp;o.done) == <span class=\"hljs-number\">0</span> &#123;\n        o.doSlow(f)\n    &#125;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(o *Once)</span> <span class=\"hljs-title\">doSlow</span><span class=\"hljs-params\">(f <span class=\"hljs-keyword\">func</span>()</span>)</span> &#123;\n    o.m.Lock()\n    <span class=\"hljs-keyword\">defer</span> o.m.Unlock()\n    <span class=\"hljs-keyword\">if</span> o.done == <span class=\"hljs-number\">0</span> &#123;\n        <span class=\"hljs-keyword\">defer</span> atomic.StoreUint32(&amp;o.done, <span class=\"hljs-number\">1</span>)\n        f()\n    &#125;\n&#125;</code></pre>\n\n<p>其实这里完全可以直接执行 <code>doSlow</code> 方法，因为它内部已经加锁了，即便有并发执行也不会有任何问题。</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(o *Once)</span> <span class=\"hljs-title\">Do</span><span class=\"hljs-params\">(f <span class=\"hljs-keyword\">func</span>()</span>)</span> &#123;\n    o.m.Lock()\n    <span class=\"hljs-keyword\">defer</span> o.m.Unlock()\n    <span class=\"hljs-keyword\">if</span> o.done == <span class=\"hljs-number\">0</span> &#123;\n        <span class=\"hljs-keyword\">defer</span> atomic.StoreUint32(&amp;o.done, <span class=\"hljs-number\">1</span>)\n        f()\n    &#125;\n&#125;</code></pre>\n\n<p>之所以要多此一举是因为 <strong>原子操作的性能要优于加锁</strong> ，对于 <code>Do</code> 方法来说，大部分调用 <code>done</code> 都是不等于 0 的，因此这样做避免了对大部分的调用进行加锁判断（只有最初的 <strong>一次或几次并发调用</strong> 会进入到 <code>doSlow</code> 方法），是一种非常经典的编程范式。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><code>sync.Once</code> 的 <a href=\"https://github.com/golang/go/blob/b634f5d97a6e65f19057c00ed2095a1a872c7fa8/src/sync/once.go#L42\"><code>Do</code></a> 方法中有这样一个技巧：先用原子操作 <strong>快速</strong> 判断是否执行过, 如果没有执行过（<code>done == 0</code>）再加锁执行 <code>f</code> 方法。</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(o *Once)</span> <span class=\"hljs-title\">Do</span><span class=\"hljs-params\">(f <span class=\"hljs-keyword\">func</span>()</span>)</span> &#123;\n    <span class=\"hljs-keyword\">if</span> atomic.LoadUint32(&amp;o.done) == <span class=\"hljs-number\">0</span> &#123;\n        o.doSlow(f)\n    &#125;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(o *Once)</span> <span class=\"hljs-title\">doSlow</span><span class=\"hljs-params\">(f <span class=\"hljs-keyword\">func</span>()</span>)</span> &#123;\n    o.m.Lock()\n    <span class=\"hljs-keyword\">defer</span> o.m.Unlock()\n    <span class=\"hljs-keyword\">if</span> o.done == <span class=\"hljs-number\">0</span> &#123;\n        <span class=\"hljs-keyword\">defer</span> atomic.StoreUint32(&amp;o.done, <span class=\"hljs-number\">1</span>)\n        f()\n    &#125;\n&#125;</code></pre>\n\n<p>其实这里完全可以直接执行 <code>doSlow</code> 方法，因为它内部已经加锁了，即便有并发执行也不会有任何问题。</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(o *Once)</span> <span class=\"hljs-title\">Do</span><span class=\"hljs-params\">(f <span class=\"hljs-keyword\">func</span>()</span>)</span> &#123;\n    o.m.Lock()\n    <span class=\"hljs-keyword\">defer</span> o.m.Unlock()\n    <span class=\"hljs-keyword\">if</span> o.done == <span class=\"hljs-number\">0</span> &#123;\n        <span class=\"hljs-keyword\">defer</span> atomic.StoreUint32(&amp;o.done, <span class=\"hljs-number\">1</span>)\n        f()\n    &#125;\n&#125;</code></pre>\n\n<p>之所以要多此一举是因为 <strong>原子操作的性能要优于加锁</strong> ，对于 <code>Do</code> 方法来说，大部分调用 <code>done</code> 都是不等于 0 的，因此这样做避免了对大部分的调用进行加锁判断（只有最初的 <strong>一次或几次并发调用</strong> 会进入到 <code>doSlow</code> 方法），是一种非常经典的编程范式。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckgkztjut0000uffybu9e6o28","category_id":"ckgkztjux0001uffy77h0ep4s","_id":"ckgkztjuz0004uffyg6s35ppx"},{"post_id":"ckjfvo33j00003ns6frt9bcsu","category_id":"ckgkztjux0001uffy77h0ep4s","_id":"ckjfvo33p00023ns65q4y4a1p"},{"post_id":"ckklbag4v0000z5fy5t9qbekm","category_id":"ckklbag4y0002z5fy7woreo2h","_id":"ckklbag510006z5fyg6b48hy3"},{"post_id":"ckklbag4x0001z5fyb71d19ob","category_id":"ckklbag4y0002z5fy7woreo2h","_id":"ckklbag520009z5fyatnxelrw"},{"post_id":"ckklbag53000gz5fybqzb9yz9","category_id":"ckklbag4y0002z5fy7woreo2h","_id":"ckklbag54000iz5fy5zvcfumh"}],"PostTag":[{"post_id":"ckgkztjut0000uffybu9e6o28","tag_id":"ckgkztjuy0002uffyfb8oglm8","_id":"ckgkztjuz0006uffy5a988avh"},{"post_id":"ckgkztjut0000uffybu9e6o28","tag_id":"ckgkztjuy0003uffy5tnw7krg","_id":"ckgkztjv00007uffyatv30kvo"},{"post_id":"ckgkztjut0000uffybu9e6o28","tag_id":"ckgkztjuz0005uffyd5so14v5","_id":"ckgkztjv00008uffy4k1oc2fu"},{"post_id":"ckjfvo33j00003ns6frt9bcsu","tag_id":"ckgkztjuy0002uffyfb8oglm8","_id":"ckjfvo33q00043ns69xpgf0cs"},{"post_id":"ckjfvo33j00003ns6frt9bcsu","tag_id":"ckgkztjuy0003uffy5tnw7krg","_id":"ckjfvo33q00053ns6dboxciw2"},{"post_id":"ckjfvo33j00003ns6frt9bcsu","tag_id":"ckjfvo33o00013ns6hgkg8fwf","_id":"ckjfvo33q00063ns6dzzx625c"},{"post_id":"ckjfvo33j00003ns6frt9bcsu","tag_id":"ckjfvo33q00033ns6584jfbio","_id":"ckjfvo33q00073ns6150305ku"},{"post_id":"ckklbag4v0000z5fy5t9qbekm","tag_id":"ckklbag4z0003z5fy7skr8hf1","_id":"ckklbag520008z5fyh5mjcs4e"},{"post_id":"ckklbag4v0000z5fy5t9qbekm","tag_id":"ckgkztjuy0003uffy5tnw7krg","_id":"ckklbag52000az5fyb2926bpc"},{"post_id":"ckklbag4x0001z5fyb71d19ob","tag_id":"ckklbag4z0003z5fy7skr8hf1","_id":"ckklbag52000dz5fy077ke3vr"},{"post_id":"ckklbag4x0001z5fyb71d19ob","tag_id":"ckgkztjuy0003uffy5tnw7krg","_id":"ckklbag53000ez5fy5hm9grr2"},{"post_id":"ckklbag4x0001z5fyb71d19ob","tag_id":"ckklbag52000bz5fyeuyme7hs","_id":"ckklbag53000fz5fyad2jaawq"},{"post_id":"ckklbag53000gz5fybqzb9yz9","tag_id":"ckklbag4z0003z5fy7skr8hf1","_id":"ckklbag54000jz5fy5jyh7w6k"},{"post_id":"ckklbag53000gz5fybqzb9yz9","tag_id":"ckgkztjuy0003uffy5tnw7krg","_id":"ckklbag55000kz5fyg5b1ekzo"},{"post_id":"ckklbag53000gz5fybqzb9yz9","tag_id":"ckklbag54000hz5fycxq70t7u","_id":"ckklbag55000lz5fyas15fh20"},{"post_id":"ckklbag4v0000z5fy5t9qbekm","tag_id":"ckklbu4vn0000fyfy079i6jlz","_id":"ckklbu4vo0001fyfya7162qt1"}],"Tag":[{"name":"k8s","_id":"ckgkztjuy0002uffyfb8oglm8"},{"name":"源码","_id":"ckgkztjuy0003uffy5tnw7krg"},{"name":"client-go","_id":"ckgkztjuz0005uffyd5so14v5"},{"name":"cache","_id":"ckjfvo33o00013ns6hgkg8fwf"},{"name":"apimachinery","_id":"ckjfvo33q00033ns6584jfbio"},{"name":"golang","_id":"ckklbag4z0003z5fy7skr8hf1"},{"name":"排序","_id":"ckklbag500005z5fyfwvjgoql"},{"name":"并发编程","_id":"ckklbag52000bz5fyeuyme7hs"},{"name":"编程范式","_id":"ckklbag54000hz5fycxq70t7u"},{"name":"堆","_id":"ckklbu4vn0000fyfy079i6jlz"}]}}