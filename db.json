{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/clipboard-use.js","path":"js/clipboard-use.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/debouncer.js","path":"js/debouncer.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/lazyload.js","path":"js/lazyload.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/hint/hint.min.css","path":"lib/hint/hint.min.css","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1601996137900},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"5b919c12e4f5f5cdebb7c17ded4f10f1ebe64811","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"557aef4c09566a4d09e33c0575ea2fb44786e179","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/README_en.md","hash":"afdfabc2763baa03ceda722c0a05e0f6680166f7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/_static_prefix.yml","hash":"d5eb27044090c50bdee4ffcf738662ce469c870a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/gulpfile.js","hash":"dc82b6be72c786721a2f5e2acc10a2a94995c540","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"8208e970e1f2267a4204b4e2aec0c458b8286395","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"f049d2e2da7e0415592371f985e3c7ae13a66ee0","modified":1601999568840},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"e967e102bab2b35b9083165c2b8e037db8e0a32d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"094357be1c2c6b477269a3f4b725d3c5dd24ef8c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"6c4ab9fcdf5f7b58238bf06276b027075872c424","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"1cfe94f46f1492a411d431b02a8d09c99cab77d5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"9534043275df504d70232c07fec7e10503b85d32","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"49a7f26815a25bbc2ed0ed78a966406f5d8c1c5e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"6abd180ff4dd1d5d22e4c70328e3c7f83d174d9c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"8cab50ead4cdb992d35710147a9a5308fb5df290","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"59551ef5d9c0dee8c162ac39a18a96dafe5e1358","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"fd72ec9e6629facf63ce8122f0fa8d492669fa6a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"8f20dca8a03aefd495d0550544f25d8c6e44333e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"5c5a5565bb13928bc92332d9b99b968673ea7dfb","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"d3a3204d9bb2b43a69c9cb0be59bada8cb91e412","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"a413dc14e4737dbcaa8fb797d37f85121ede6551","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/lint.yaml","hash":"628f8d7655fdba149f5a9b0232df5c3225eda9da","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/beian.ejs","hash":"4f3acc8dc822c85d0d778552a15875f71c0cd80a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/css.ejs","hash":"44d7248fb15361fd23b774f0816c6480b8fdc52e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/footer.ejs","hash":"03defcd4409dce27447aa8dfe7ce41a2d47e373b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/head.ejs","hash":"55f62c4766f5d505e8307e667f83ea459b84dfb6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/nav.ejs","hash":"70490c67b7313ae305d39331238232fe62f094f1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/paginator.ejs","hash":"783eee847562ce14db8f723b4ae742fb69aaf620","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/post-meta.ejs","hash":"7c40672443ba61b62b68a9aa6685ea944dbbb061","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/scripts.ejs","hash":"9f9e40a348771463cc70d6592198604ca49fc050","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/toc.ejs","hash":"3cf1d9b9032919d6b936e1f2410911df3b325670","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"a6ab2c6d9f9ba58cd1fabb85c2817874246fd525","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"6665f19fa30cbbe0853d8140a0832f8638538f89","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"01439b3d7abdeb5e51f810d784181c1d420be55d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"d45dce23532c17367c7eb86b94afa8c9e40d16c6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"99ab4551dc9c035abcc3bf4da5def2f63449d7ec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"9045f47c7a71aab39f16cffb3e3847b752c2e0f1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"e58d422eddb44c1be893f65f79f4c7feecfe6d5f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"63468f7875c09d9557fe8315afc97175745d9087","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"0886cfe3f8589671a1d289495e359c20a9908080","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/join-path.js","hash":"629e7deb3955f750c1cfa6fc773f412e020fcef4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"61e9555f99edcb23d55361c7154e23af33153ecb","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","hash":"cd06ec95988bc0287d444fc98d4a6d2cc576ace4","modified":1602001657244},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/clipboard-use.js","hash":"f0ffe3df1deeb3cc36adfee2ab839368fb28d1c9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"03d5315b752cd3e13749cca790783a1e1cfab0a8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/debouncer.js","hash":"045f324777bdfb99d4c17b1806169f029f897a65","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/lazyload.js","hash":"792deca48c12512d3e612f0de092ffcff3ca3e34","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"13d5ef2fe68c49bd6096781034dbb26c190b5176","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"9b06e2e2a2bb92e27d15a700f28f880317c25cfa","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/main.js","hash":"a6def6368d288892088f78fd401e7170e3e81a13","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/changyan.ejs","hash":"13c0b62854668fd83287dff3792997baeeb3a2c7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/disqus.ejs","hash":"eeb3462cbedd195156aa671fb522bebee0274b5e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/gitalk.ejs","hash":"096fef408349db4ebbec84cf20a373dd46c8f4ff","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/remark42.ejs","hash":"3c254c1b7bc5a4c6bd5b724514d463608408018b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/livere.ejs","hash":"f1e5d89cc98e2f6e067e5cd3db728127ccff0105","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/utterances.ejs","hash":"2b9a49594e9aea4dc8fdd606a63c8c5b9189e325","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/valine.ejs","hash":"37941b3c6f66f1f22aeff734802373657dfdfb99","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/analytics.ejs","hash":"557077a8825fffc0a2c7fe2b29f319287950244f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/aplayer.ejs","hash":"e843cdbe64af3dee9385eb1d763539d3ac10ed72","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/anchor.ejs","hash":"3738c2ef427b4b400225b92e638a17b7ab2125ed","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/daovoice.ejs","hash":"cfc684ba48608abd25afd155ee373d9936bbe84e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/fancybox.ejs","hash":"c447e35c93c61a70c1c2dfc34948615832989660","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/leancloud.ejs","hash":"7807e58722dcf992fba11bc879b0fac0e904dc76","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/local-search.ejs","hash":"03b024c7bab51b64e5187c9dbfac039d020f1e97","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/math.ejs","hash":"76c4e0608ae362a265ac5e9c0fc49f75c1bc568e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/tocjs.ejs","hash":"2d35295dba2bb912d6ce2ec7747af06bfdc82edb","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/mouse-click.ejs","hash":"eb19991199c201ceb103a6ef025e4dfd1e7dbfb7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/typed.ejs","hash":"38334350425008d1f64323de221457ee0948af0e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"da4c281a8b2d2ed813da1236950c9dff87334adc","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"96d56372cad997b09c26dbd29a19f917140c6ab0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"ee7dfef805af96195c11223cca53983deace8bda","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"a25a40036ef38c8dc92574079007882a0d75338a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/preset-configs.js","hash":"202459c9444b1ba967396db3625af261b0b19820","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/version.js","hash":"0250fb16c7c798afd1f7fc816163ea0728765568","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"fe96204aa2e7ee4f7f404c9e90752a8ff822d779","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"15d2786d00418e61022475194ad76445d68e27ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"aa2528e71c290dc43b69dfbdcf4d8d6c258015a4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"f7004d597163e0af7b9107b0be1df12f4c0a7bc0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"fab8441a0b8d8f9db6c8370013659c035345ae79","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/rewrite.styl","hash":"4f939807936632f2ff2504f139648033aa351957","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"c443551deb389102e65cbb2441f60e8c20712ee8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"cd4ebb1426abed9fda93b797b02c6d5dd71dc2a1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post.styl","hash":"1e7e4290a7653f748e0a46c81cc6aed4564f8bf4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/tag_plugin.styl","hash":"cbb49a17fcc030029f0c2fbe1e056613109d1ecc","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"ec4e9678d2f4df03b1ad773adf57acc83a947687","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"2c9e05a354d4be820646a1c99f814740f299ed37","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"6b8340a41afc6b6e5f30dc9e912a0e0265446963","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"7c8170d0e2de47570fe8ed523f10ee1c33138a9f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"fe74d031acef4403e1510d4cce5bc7accd641780","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"e4ad804ab26bdbf5b55abbc5548b6db395cfed04","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":499162500000},{"_id":"source/about/index.md","hash":"d1862679b4e3a6316f40cc05510ff9c609cda47b","modified":1601999904005},{"_id":"themes/fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1599451061000},{"_id":"themes/fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1599451061000},{"_id":"themes/fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1599451061000},{"_id":"themes/fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1599451061000},{"_id":"themes/fluid/.gitignore","hash":"bd095eee271360a38772ee1a42d4f000fb722e5f","modified":1599451061000},{"_id":"themes/fluid/LICENSE","hash":"5b919c12e4f5f5cdebb7c17ded4f10f1ebe64811","modified":1599451061000},{"_id":"themes/fluid/README.md","hash":"557aef4c09566a4d09e33c0575ea2fb44786e179","modified":1599451061000},{"_id":"themes/fluid/README_en.md","hash":"afdfabc2763baa03ceda722c0a05e0f6680166f7","modified":1599451061000},{"_id":"themes/fluid/_config.yml","hash":"8208e970e1f2267a4204b4e2aec0c458b8286395","modified":1599451061000},{"_id":"themes/fluid/_static_prefix.yml","hash":"d5eb27044090c50bdee4ffcf738662ce469c870a","modified":1599451061000},{"_id":"themes/fluid/gulpfile.js","hash":"dc82b6be72c786721a2f5e2acc10a2a94995c540","modified":1599451061000},{"_id":"themes/fluid/package.json","hash":"2390818b24d2f525bfca6cbc7f55e6650a513f3d","modified":1599451061000},{"_id":"themes/fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":1599451061000},{"_id":"themes/fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":1599451061000},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":1599451061000},{"_id":"themes/fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":1599451061000},{"_id":"themes/fluid/layout/about.ejs","hash":"e967e102bab2b35b9083165c2b8e037db8e0a32d","modified":1599451061000},{"_id":"themes/fluid/layout/archive.ejs","hash":"094357be1c2c6b477269a3f4b725d3c5dd24ef8c","modified":1599451061000},{"_id":"themes/fluid/layout/categories.ejs","hash":"6c4ab9fcdf5f7b58238bf06276b027075872c424","modified":1599451061000},{"_id":"themes/fluid/layout/category.ejs","hash":"1cfe94f46f1492a411d431b02a8d09c99cab77d5","modified":1599451061000},{"_id":"themes/fluid/layout/index.ejs","hash":"9534043275df504d70232c07fec7e10503b85d32","modified":1599451061000},{"_id":"themes/fluid/layout/layout.ejs","hash":"49a7f26815a25bbc2ed0ed78a966406f5d8c1c5e","modified":1599451061000},{"_id":"themes/fluid/layout/links.ejs","hash":"6abd180ff4dd1d5d22e4c70328e3c7f83d174d9c","modified":1599451061000},{"_id":"themes/fluid/layout/page.ejs","hash":"8cab50ead4cdb992d35710147a9a5308fb5df290","modified":1599451061000},{"_id":"themes/fluid/layout/post.ejs","hash":"59551ef5d9c0dee8c162ac39a18a96dafe5e1358","modified":1599451061000},{"_id":"themes/fluid/layout/tag.ejs","hash":"fd72ec9e6629facf63ce8122f0fa8d492669fa6a","modified":1599451061000},{"_id":"themes/fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1599451061000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"8f20dca8a03aefd495d0550544f25d8c6e44333e","modified":1599451061000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"5c5a5565bb13928bc92332d9b99b968673ea7dfb","modified":1599451061000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"d3a3204d9bb2b43a69c9cb0be59bada8cb91e412","modified":1599451061000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"a413dc14e4737dbcaa8fb797d37f85121ede6551","modified":1599451061000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":1599451061000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":1599451061000},{"_id":"themes/fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1599451061000},{"_id":"themes/fluid/.github/workflows/lint.yaml","hash":"628f8d7655fdba149f5a9b0232df5c3225eda9da","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/beian.ejs","hash":"4f3acc8dc822c85d0d778552a15875f71c0cd80a","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/css.ejs","hash":"44d7248fb15361fd23b774f0816c6480b8fdc52e","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/footer.ejs","hash":"03defcd4409dce27447aa8dfe7ce41a2d47e373b","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/head.ejs","hash":"55f62c4766f5d505e8307e667f83ea459b84dfb6","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/nav.ejs","hash":"70490c67b7313ae305d39331238232fe62f094f1","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/paginator.ejs","hash":"783eee847562ce14db8f723b4ae742fb69aaf620","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/post-meta.ejs","hash":"7c40672443ba61b62b68a9aa6685ea944dbbb061","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/scripts.ejs","hash":"9f9e40a348771463cc70d6592198604ca49fc050","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/toc.ejs","hash":"3cf1d9b9032919d6b936e1f2410911df3b325670","modified":1599451061000},{"_id":"themes/fluid/scripts/events/index.js","hash":"a6ab2c6d9f9ba58cd1fabb85c2817874246fd525","modified":1599451061000},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"6665f19fa30cbbe0853d8140a0832f8638538f89","modified":1599451061000},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1599451061000},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"01439b3d7abdeb5e51f810d784181c1d420be55d","modified":1599451061000},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"d45dce23532c17367c7eb86b94afa8c9e40d16c6","modified":1599451061000},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"99ab4551dc9c035abcc3bf4da5def2f63449d7ec","modified":1599451061000},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"9045f47c7a71aab39f16cffb3e3847b752c2e0f1","modified":1599451061000},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"e58d422eddb44c1be893f65f79f4c7feecfe6d5f","modified":1599451061000},{"_id":"themes/fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1599451061000},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"63468f7875c09d9557fe8315afc97175745d9087","modified":1599451061000},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1599451061000},{"_id":"themes/fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1599451061000},{"_id":"themes/fluid/scripts/tags/note.js","hash":"0886cfe3f8589671a1d289495e359c20a9908080","modified":1599451061000},{"_id":"themes/fluid/scripts/utils/join-path.js","hash":"629e7deb3955f750c1cfa6fc773f412e020fcef4","modified":1599451061000},{"_id":"themes/fluid/scripts/utils/object.js","hash":"61e9555f99edcb23d55361c7154e23af33153ecb","modified":1599451061000},{"_id":"themes/fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":1599451061000},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1599451061000},{"_id":"themes/fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1599451061000},{"_id":"themes/fluid/source/img/favicon.png","hash":"cd06ec95988bc0287d444fc98d4a6d2cc576ace4","modified":1602007038894},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1599451061000},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1599451061000},{"_id":"themes/fluid/source/js/clipboard-use.js","hash":"f0ffe3df1deeb3cc36adfee2ab839368fb28d1c9","modified":1599451061000},{"_id":"themes/fluid/source/js/color-schema.js","hash":"03d5315b752cd3e13749cca790783a1e1cfab0a8","modified":1599451061000},{"_id":"themes/fluid/source/js/debouncer.js","hash":"045f324777bdfb99d4c17b1806169f029f897a65","modified":1599451061000},{"_id":"themes/fluid/source/js/lazyload.js","hash":"792deca48c12512d3e612f0de092ffcff3ca3e34","modified":1599451061000},{"_id":"themes/fluid/source/js/local-search.js","hash":"13d5ef2fe68c49bd6096781034dbb26c190b5176","modified":1599451061000},{"_id":"themes/fluid/source/js/main.js","hash":"a6def6368d288892088f78fd401e7170e3e81a13","modified":1599451061000},{"_id":"themes/fluid/source/js/utils.js","hash":"9b06e2e2a2bb92e27d15a700f28f880317c25cfa","modified":1599451061000},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/comments/changyan.ejs","hash":"13c0b62854668fd83287dff3792997baeeb3a2c7","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/comments/disqus.ejs","hash":"eeb3462cbedd195156aa671fb522bebee0274b5e","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/comments/gitalk.ejs","hash":"096fef408349db4ebbec84cf20a373dd46c8f4ff","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/comments/livere.ejs","hash":"f1e5d89cc98e2f6e067e5cd3db728127ccff0105","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/comments/remark42.ejs","hash":"3c254c1b7bc5a4c6bd5b724514d463608408018b","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/comments/utterances.ejs","hash":"2b9a49594e9aea4dc8fdd606a63c8c5b9189e325","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/comments/valine.ejs","hash":"37941b3c6f66f1f22aeff734802373657dfdfb99","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/plugins/analytics.ejs","hash":"557077a8825fffc0a2c7fe2b29f319287950244f","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/plugins/anchor.ejs","hash":"3738c2ef427b4b400225b92e638a17b7ab2125ed","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/plugins/aplayer.ejs","hash":"e843cdbe64af3dee9385eb1d763539d3ac10ed72","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/plugins/daovoice.ejs","hash":"cfc684ba48608abd25afd155ee373d9936bbe84e","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/plugins/fancybox.ejs","hash":"c447e35c93c61a70c1c2dfc34948615832989660","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/plugins/leancloud.ejs","hash":"7807e58722dcf992fba11bc879b0fac0e904dc76","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/plugins/local-search.ejs","hash":"03b024c7bab51b64e5187c9dbfac039d020f1e97","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/plugins/math.ejs","hash":"76c4e0608ae362a265ac5e9c0fc49f75c1bc568e","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/plugins/mouse-click.ejs","hash":"eb19991199c201ceb103a6ef025e4dfd1e7dbfb7","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/plugins/tocjs.ejs","hash":"2d35295dba2bb912d6ce2ec7747af06bfdc82edb","modified":1599451061000},{"_id":"themes/fluid/layout/_partial/plugins/typed.ejs","hash":"38334350425008d1f64323de221457ee0948af0e","modified":1599451061000},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":1599451061000},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"da4c281a8b2d2ed813da1236950c9dff87334adc","modified":1599451061000},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"96d56372cad997b09c26dbd29a19f917140c6ab0","modified":1599451061000},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"ee7dfef805af96195c11223cca53983deace8bda","modified":1599451061000},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"a25a40036ef38c8dc92574079007882a0d75338a","modified":1599451061000},{"_id":"themes/fluid/scripts/events/lib/preset-configs.js","hash":"202459c9444b1ba967396db3625af261b0b19820","modified":1599451061000},{"_id":"themes/fluid/scripts/events/lib/version.js","hash":"0250fb16c7c798afd1f7fc816163ea0728765568","modified":1599451061000},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1599451061000},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1599451061000},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"fe96204aa2e7ee4f7f404c9e90752a8ff822d779","modified":1599451061000},{"_id":"themes/fluid/source/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"15d2786d00418e61022475194ad76445d68e27ea","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"aa2528e71c290dc43b69dfbdcf4d8d6c258015a4","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"f7004d597163e0af7b9107b0be1df12f4c0a7bc0","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"fab8441a0b8d8f9db6c8370013659c035345ae79","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/rewrite.styl","hash":"4f939807936632f2ff2504f139648033aa351957","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"c443551deb389102e65cbb2441f60e8c20712ee8","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"cd4ebb1426abed9fda93b797b02c6d5dd71dc2a1","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_post/post.styl","hash":"1e7e4290a7653f748e0a46c81cc6aed4564f8bf4","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_post/tag_plugin.styl","hash":"cbb49a17fcc030029f0c2fbe1e056613109d1ecc","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"ec4e9678d2f4df03b1ad773adf57acc83a947687","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"2c9e05a354d4be820646a1c99f814740f299ed37","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"6b8340a41afc6b6e5f30dc9e912a0e0265446963","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"7c8170d0e2de47570fe8ed523f10ee1c33138a9f","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"fe74d031acef4403e1510d4cce5bc7accd641780","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"e4ad804ab26bdbf5b55abbc5548b6db395cfed04","modified":1599451061000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1599451061000},{"_id":"source/_posts/Kubernetes-源码阅读-Indexer.md","hash":"49d4349774c9499862cede9398b50019539b416c","modified":1603385405248},{"_id":"source/_posts/Kubernetes-源码阅读-Expiring.md","hash":"1bcd46a1395ba271ac678b5eaeb7e53156aa7ed8","modified":1609602370358},{"_id":"source/CNAME","hash":"27d9ca69399b9988b566e821b6dcb3b3d6c5e6b2","modified":1603385738195}],"Category":[{"name":"kubernetes","_id":"ckgkztjux0001uffy77h0ep4s"}],"Data":[],"Page":[{"title":"about","date":"2020-10-06T15:58:23.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-10-06 23:58:23\n---\n","updated":"2020-10-06T15:58:24.005Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckfy5ebqc0000lvys5b1d8en5","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Kubernetes 源码阅读 -- Indexer","date":"2020-10-22T15:36:37.000Z","_content":"\n## 概述\n\n[`Indexer`](https://github.com/kubernetes/client-go/blob/d1a4fe5f2d96df815903781843870155cb4f5f40/tools/cache/index.go#L35) 是 kubernetes 中用于在内存中缓存资源对象的接口，支持通过 Key 对存储的资源对象进行增、删、查、改操作， 同时也可以对存储的对象进行倒排索引。\n\n`cache` 是 `Indexer` 的实现方式，其定义如下：\n\n``` Go\ntype cache struct {\n    cacheStorage    ThreadSafeStore\n    keyFunc         KeyFunc\n}\n```\n\n`ThreadSafeStore` 定义了一个线程安全的存储接口，由 `threadSafeMap` 实现。\n\nThreadSafeStore 与 Indexer 非常相似，前者可以看作是后者的一种特例。ThreadSafeStore 操作资源对象时需要指定对象的 key，而 Indexer 则不需要，是在 Indexer 的实现结构 cache 中通过 `keyFunc` 动态计算资源对象的 key。因此可以认为 `Indexer = ThreadSafeStore + KeyFunc`。\n\n## Indexer\n\nIndexer 与其它数据结构的关系如下：\n![Indexer UML](http://lc-C7OxrU7U.cn-n1.lcfile.com/c34bc3865ff4230a648a.png/diagram-16025179975213868166.png)\n\n从图中可以看出没有索引的 cache 就是一个 Store，源码中 Indexer 和 Store 的创建方式分别如下：\n\n```GO\n// NewStore returns a Store implemented simply with a map and a lock.\nfunc NewStore(keyFunc KeyFunc) Store {\n    return &cache{\n        cacheStorage: NewThreadSafeStore(Indexers{}, Indices{}),\n        keyFunc:      keyFunc,\n    }\n}\n\n// NewIndexer returns an Indexer implemented simply with a map and a lock.\nfunc NewIndexer(keyFunc KeyFunc, indexers Indexers) Indexer {\n    return &cache{\n        cacheStorage: NewThreadSafeStore(indexers, Indices{}),\n        keyFunc:      keyFunc,\n    }\n\ntype KeyFunc func(obj interface{}) (string, error)\n```\n\n`ThreadSafeStore` 通过 `indexers` 创建索引，indexers 是一个如下的 map：\n\n```GO\ntype Indexers map[string]IndexFunc\n\ntype IndexFunc func(obj interface{}) ([]string, error)\n```\n\nIndexers 的 Key 是索引名称，值是 _根据资源对象创建计算该索引的索引值的函数_\n\n`Indices` 是存储倒排索引的数据结构：\n\n```Go\ntype Indices map[string]Index\n\ntype Index map[string]sets.String\n```\n\nIndices 的 Key 是索引名, 值是对应的索引 Index\nIndex 的 Key 是索引值，值是具有该索引值的资源对象的 Key\n\n## KeyFunc 与 IndexFunc\n\nKeyFunc 与 IndexFunc 对比如下：\n\n- KeyFunc: f(obj) -> key\n- IndexFunc: f(obj) -> indexValue1, indexValue2 ...\n\n由上对比可知 KeyFunc 是 IndexFunc 的一个特例，当 IndexFunc 只返回一个索引值时它就退化为 KeyFunc，client-go 中也提供了由 IndexFunc 到 KeyFunc 的适配函数：\n\n```Go\nfunc IndexFuncToKeyFuncAdapter(indexFunc IndexFunc) KeyFunc {\n    return func(obj interface{}) (string, error) {\n        indexKeys, err := indexFunc(obj)\n        if err != nil {\n            return \"\", err\n        }\n        if len(indexKeys) > 1 {\n            return \"\", fmt.Errorf(\"too many keys: %v\", indexKeys)\n        }\n        if len(indexKeys) == 0 {\n            return \"\", fmt.Errorf(\"unexpected empty indexKeys\")\n        }\n        return indexKeys[0], nil\n    }\n}\n```\n\n常用的 KeyFunc 有 `MetaNamespaceKeyFunc`, 即 f(obj) -> namespace/name\n常用的 IndexFunc 则有 `MetaNamespaceIndexFunc`, 即 f(obj) -> [namespace]\n\n## threadSafeMap\n\n`threadSafeMap` 是 `ThreadSafeStore` 的具体实现，通过 `sync.RWMutex` 实现线程安全。threadSafeMap 只能保证其定义的操作是线程安全的，直接对 Get/List 等操作返回的结果进行修改是无法保证的。\n\nthreadSafeMap 的数据结构如下，它的增删查改操作主要就是操作 `items`，同时通过 indexers 计算资源对象在各个索引中的值，通过  `updateIndices` 和 `deleteFromIndices` 对 `indices` 进行更新。\n\n```Go\ntype threadSafeMap struct {\n    lock  sync.RWMutex\n    items map[string]interface{}\n\n    // indexers maps a name to an IndexFunc\n    indexers Indexers\n    // indices maps a name to an Index\n    indices Indices\n}\n```\n","source":"_posts/Kubernetes-源码阅读-Indexer.md","raw":"---\ntitle: Kubernetes 源码阅读 -- Indexer\ndate: 2020-10-22 23:36:37\ntags: [k8s, 源码, client-go]\ncategories: kubernetes\n---\n\n## 概述\n\n[`Indexer`](https://github.com/kubernetes/client-go/blob/d1a4fe5f2d96df815903781843870155cb4f5f40/tools/cache/index.go#L35) 是 kubernetes 中用于在内存中缓存资源对象的接口，支持通过 Key 对存储的资源对象进行增、删、查、改操作， 同时也可以对存储的对象进行倒排索引。\n\n`cache` 是 `Indexer` 的实现方式，其定义如下：\n\n``` Go\ntype cache struct {\n    cacheStorage    ThreadSafeStore\n    keyFunc         KeyFunc\n}\n```\n\n`ThreadSafeStore` 定义了一个线程安全的存储接口，由 `threadSafeMap` 实现。\n\nThreadSafeStore 与 Indexer 非常相似，前者可以看作是后者的一种特例。ThreadSafeStore 操作资源对象时需要指定对象的 key，而 Indexer 则不需要，是在 Indexer 的实现结构 cache 中通过 `keyFunc` 动态计算资源对象的 key。因此可以认为 `Indexer = ThreadSafeStore + KeyFunc`。\n\n## Indexer\n\nIndexer 与其它数据结构的关系如下：\n![Indexer UML](http://lc-C7OxrU7U.cn-n1.lcfile.com/c34bc3865ff4230a648a.png/diagram-16025179975213868166.png)\n\n从图中可以看出没有索引的 cache 就是一个 Store，源码中 Indexer 和 Store 的创建方式分别如下：\n\n```GO\n// NewStore returns a Store implemented simply with a map and a lock.\nfunc NewStore(keyFunc KeyFunc) Store {\n    return &cache{\n        cacheStorage: NewThreadSafeStore(Indexers{}, Indices{}),\n        keyFunc:      keyFunc,\n    }\n}\n\n// NewIndexer returns an Indexer implemented simply with a map and a lock.\nfunc NewIndexer(keyFunc KeyFunc, indexers Indexers) Indexer {\n    return &cache{\n        cacheStorage: NewThreadSafeStore(indexers, Indices{}),\n        keyFunc:      keyFunc,\n    }\n\ntype KeyFunc func(obj interface{}) (string, error)\n```\n\n`ThreadSafeStore` 通过 `indexers` 创建索引，indexers 是一个如下的 map：\n\n```GO\ntype Indexers map[string]IndexFunc\n\ntype IndexFunc func(obj interface{}) ([]string, error)\n```\n\nIndexers 的 Key 是索引名称，值是 _根据资源对象创建计算该索引的索引值的函数_\n\n`Indices` 是存储倒排索引的数据结构：\n\n```Go\ntype Indices map[string]Index\n\ntype Index map[string]sets.String\n```\n\nIndices 的 Key 是索引名, 值是对应的索引 Index\nIndex 的 Key 是索引值，值是具有该索引值的资源对象的 Key\n\n## KeyFunc 与 IndexFunc\n\nKeyFunc 与 IndexFunc 对比如下：\n\n- KeyFunc: f(obj) -> key\n- IndexFunc: f(obj) -> indexValue1, indexValue2 ...\n\n由上对比可知 KeyFunc 是 IndexFunc 的一个特例，当 IndexFunc 只返回一个索引值时它就退化为 KeyFunc，client-go 中也提供了由 IndexFunc 到 KeyFunc 的适配函数：\n\n```Go\nfunc IndexFuncToKeyFuncAdapter(indexFunc IndexFunc) KeyFunc {\n    return func(obj interface{}) (string, error) {\n        indexKeys, err := indexFunc(obj)\n        if err != nil {\n            return \"\", err\n        }\n        if len(indexKeys) > 1 {\n            return \"\", fmt.Errorf(\"too many keys: %v\", indexKeys)\n        }\n        if len(indexKeys) == 0 {\n            return \"\", fmt.Errorf(\"unexpected empty indexKeys\")\n        }\n        return indexKeys[0], nil\n    }\n}\n```\n\n常用的 KeyFunc 有 `MetaNamespaceKeyFunc`, 即 f(obj) -> namespace/name\n常用的 IndexFunc 则有 `MetaNamespaceIndexFunc`, 即 f(obj) -> [namespace]\n\n## threadSafeMap\n\n`threadSafeMap` 是 `ThreadSafeStore` 的具体实现，通过 `sync.RWMutex` 实现线程安全。threadSafeMap 只能保证其定义的操作是线程安全的，直接对 Get/List 等操作返回的结果进行修改是无法保证的。\n\nthreadSafeMap 的数据结构如下，它的增删查改操作主要就是操作 `items`，同时通过 indexers 计算资源对象在各个索引中的值，通过  `updateIndices` 和 `deleteFromIndices` 对 `indices` 进行更新。\n\n```Go\ntype threadSafeMap struct {\n    lock  sync.RWMutex\n    items map[string]interface{}\n\n    // indexers maps a name to an IndexFunc\n    indexers Indexers\n    // indices maps a name to an Index\n    indices Indices\n}\n```\n","slug":"Kubernetes-源码阅读-Indexer","published":1,"updated":"2020-10-22T16:50:05.248Z","_id":"ckgkztjut0000uffybu9e6o28","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><a href=\"https://github.com/kubernetes/client-go/blob/d1a4fe5f2d96df815903781843870155cb4f5f40/tools/cache/index.go#L35\"><code>Indexer</code></a> 是 kubernetes 中用于在内存中缓存资源对象的接口，支持通过 Key 对存储的资源对象进行增、删、查、改操作， 同时也可以对存储的对象进行倒排索引。</p>\n<p><code>cache</code> 是 <code>Indexer</code> 的实现方式，其定义如下：</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> cache <span class=\"hljs-keyword\">struct</span> &#123;\n    cacheStorage    ThreadSafeStore\n    keyFunc         KeyFunc\n&#125;</code></pre>\n\n<p><code>ThreadSafeStore</code> 定义了一个线程安全的存储接口，由 <code>threadSafeMap</code> 实现。</p>\n<p>ThreadSafeStore 与 Indexer 非常相似，前者可以看作是后者的一种特例。ThreadSafeStore 操作资源对象时需要指定对象的 key，而 Indexer 则不需要，是在 Indexer 的实现结构 cache 中通过 <code>keyFunc</code> 动态计算资源对象的 key。因此可以认为 <code>Indexer = ThreadSafeStore + KeyFunc</code>。</p>\n<h2 id=\"Indexer\"><a href=\"#Indexer\" class=\"headerlink\" title=\"Indexer\"></a>Indexer</h2><p>Indexer 与其它数据结构的关系如下：<br><img src=\"http://lc-c7oxru7u.cn-n1.lcfile.com/c34bc3865ff4230a648a.png/diagram-16025179975213868166.png\" alt=\"Indexer UML\"></p>\n<p>从图中可以看出没有索引的 cache 就是一个 Store，源码中 Indexer 和 Store 的创建方式分别如下：</p>\n<pre><code class=\"hljs GO\"><span class=\"hljs-comment\">// NewStore returns a Store implemented simply with a map and a lock.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">NewStore</span><span class=\"hljs-params\">(keyFunc KeyFunc)</span> <span class=\"hljs-title\">Store</span></span> &#123;\n    <span class=\"hljs-keyword\">return</span> &amp;cache&#123;\n        cacheStorage: NewThreadSafeStore(Indexers&#123;&#125;, Indices&#123;&#125;),\n        keyFunc:      keyFunc,\n    &#125;\n&#125;\n\n<span class=\"hljs-comment\">// NewIndexer returns an Indexer implemented simply with a map and a lock.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">NewIndexer</span><span class=\"hljs-params\">(keyFunc KeyFunc, indexers Indexers)</span> <span class=\"hljs-title\">Indexer</span></span> &#123;\n    <span class=\"hljs-keyword\">return</span> &amp;cache&#123;\n        cacheStorage: NewThreadSafeStore(indexers, Indices&#123;&#125;),\n        keyFunc:      keyFunc,\n    &#125;\n\n<span class=\"hljs-keyword\">type</span> KeyFunc <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(obj <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">string</span>, error)</span></span></code></pre>\n\n<p><code>ThreadSafeStore</code> 通过 <code>indexers</code> 创建索引，indexers 是一个如下的 map：</p>\n<pre><code class=\"hljs GO\"><span class=\"hljs-keyword\">type</span> Indexers <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]IndexFunc\n\n<span class=\"hljs-keyword\">type</span> IndexFunc <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(obj <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span> <span class=\"hljs-params\">([]<span class=\"hljs-keyword\">string</span>, error)</span></span></code></pre>\n\n<p>Indexers 的 Key 是索引名称，值是 <em>根据资源对象创建计算该索引的索引值的函数</em></p>\n<p><code>Indices</code> 是存储倒排索引的数据结构：</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> Indices <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]Index\n\n<span class=\"hljs-keyword\">type</span> Index <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]sets.String</code></pre>\n\n<p>Indices 的 Key 是索引名, 值是对应的索引 Index<br>Index 的 Key 是索引值，值是具有该索引值的资源对象的 Key</p>\n<h2 id=\"KeyFunc-与-IndexFunc\"><a href=\"#KeyFunc-与-IndexFunc\" class=\"headerlink\" title=\"KeyFunc 与 IndexFunc\"></a>KeyFunc 与 IndexFunc</h2><p>KeyFunc 与 IndexFunc 对比如下：</p>\n<ul>\n<li>KeyFunc: f(obj) -&gt; key</li>\n<li>IndexFunc: f(obj) -&gt; indexValue1, indexValue2 …</li>\n</ul>\n<p>由上对比可知 KeyFunc 是 IndexFunc 的一个特例，当 IndexFunc 只返回一个索引值时它就退化为 KeyFunc，client-go 中也提供了由 IndexFunc 到 KeyFunc 的适配函数：</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">IndexFuncToKeyFuncAdapter</span><span class=\"hljs-params\">(indexFunc IndexFunc)</span> <span class=\"hljs-title\">KeyFunc</span></span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(obj <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">string</span>, error)</span></span> &#123;\n        indexKeys, err := indexFunc(obj)\n        <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>, err\n        &#125;\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(indexKeys) &gt; <span class=\"hljs-number\">1</span> &#123;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>, fmt.Errorf(<span class=\"hljs-string\">&quot;too many keys: %v&quot;</span>, indexKeys)\n        &#125;\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(indexKeys) == <span class=\"hljs-number\">0</span> &#123;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>, fmt.Errorf(<span class=\"hljs-string\">&quot;unexpected empty indexKeys&quot;</span>)\n        &#125;\n        <span class=\"hljs-keyword\">return</span> indexKeys[<span class=\"hljs-number\">0</span>], <span class=\"hljs-literal\">nil</span>\n    &#125;\n&#125;</code></pre>\n\n<p>常用的 KeyFunc 有 <code>MetaNamespaceKeyFunc</code>, 即 f(obj) -&gt; namespace/name<br>常用的 IndexFunc 则有 <code>MetaNamespaceIndexFunc</code>, 即 f(obj) -&gt; [namespace]</p>\n<h2 id=\"threadSafeMap\"><a href=\"#threadSafeMap\" class=\"headerlink\" title=\"threadSafeMap\"></a>threadSafeMap</h2><p><code>threadSafeMap</code> 是 <code>ThreadSafeStore</code> 的具体实现，通过 <code>sync.RWMutex</code> 实现线程安全。threadSafeMap 只能保证其定义的操作是线程安全的，直接对 Get/List 等操作返回的结果进行修改是无法保证的。</p>\n<p>threadSafeMap 的数据结构如下，它的增删查改操作主要就是操作 <code>items</code>，同时通过 indexers 计算资源对象在各个索引中的值，通过  <code>updateIndices</code> 和 <code>deleteFromIndices</code> 对 <code>indices</code> 进行更新。</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> threadSafeMap <span class=\"hljs-keyword\">struct</span> &#123;\n    lock  sync.RWMutex\n    items <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]<span class=\"hljs-keyword\">interface</span>&#123;&#125;\n\n    <span class=\"hljs-comment\">// indexers maps a name to an IndexFunc</span>\n    indexers Indexers\n    <span class=\"hljs-comment\">// indices maps a name to an Index</span>\n    indices Indices\n&#125;</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><a href=\"https://github.com/kubernetes/client-go/blob/d1a4fe5f2d96df815903781843870155cb4f5f40/tools/cache/index.go#L35\"><code>Indexer</code></a> 是 kubernetes 中用于在内存中缓存资源对象的接口，支持通过 Key 对存储的资源对象进行增、删、查、改操作， 同时也可以对存储的对象进行倒排索引。</p>\n<p><code>cache</code> 是 <code>Indexer</code> 的实现方式，其定义如下：</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> cache <span class=\"hljs-keyword\">struct</span> &#123;\n    cacheStorage    ThreadSafeStore\n    keyFunc         KeyFunc\n&#125;</code></pre>\n\n<p><code>ThreadSafeStore</code> 定义了一个线程安全的存储接口，由 <code>threadSafeMap</code> 实现。</p>\n<p>ThreadSafeStore 与 Indexer 非常相似，前者可以看作是后者的一种特例。ThreadSafeStore 操作资源对象时需要指定对象的 key，而 Indexer 则不需要，是在 Indexer 的实现结构 cache 中通过 <code>keyFunc</code> 动态计算资源对象的 key。因此可以认为 <code>Indexer = ThreadSafeStore + KeyFunc</code>。</p>\n<h2 id=\"Indexer\"><a href=\"#Indexer\" class=\"headerlink\" title=\"Indexer\"></a>Indexer</h2><p>Indexer 与其它数据结构的关系如下：<br><img src=\"http://lc-c7oxru7u.cn-n1.lcfile.com/c34bc3865ff4230a648a.png/diagram-16025179975213868166.png\" alt=\"Indexer UML\"></p>\n<p>从图中可以看出没有索引的 cache 就是一个 Store，源码中 Indexer 和 Store 的创建方式分别如下：</p>\n<pre><code class=\"hljs GO\"><span class=\"hljs-comment\">// NewStore returns a Store implemented simply with a map and a lock.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">NewStore</span><span class=\"hljs-params\">(keyFunc KeyFunc)</span> <span class=\"hljs-title\">Store</span></span> &#123;\n    <span class=\"hljs-keyword\">return</span> &amp;cache&#123;\n        cacheStorage: NewThreadSafeStore(Indexers&#123;&#125;, Indices&#123;&#125;),\n        keyFunc:      keyFunc,\n    &#125;\n&#125;\n\n<span class=\"hljs-comment\">// NewIndexer returns an Indexer implemented simply with a map and a lock.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">NewIndexer</span><span class=\"hljs-params\">(keyFunc KeyFunc, indexers Indexers)</span> <span class=\"hljs-title\">Indexer</span></span> &#123;\n    <span class=\"hljs-keyword\">return</span> &amp;cache&#123;\n        cacheStorage: NewThreadSafeStore(indexers, Indices&#123;&#125;),\n        keyFunc:      keyFunc,\n    &#125;\n\n<span class=\"hljs-keyword\">type</span> KeyFunc <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(obj <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">string</span>, error)</span></span></code></pre>\n\n<p><code>ThreadSafeStore</code> 通过 <code>indexers</code> 创建索引，indexers 是一个如下的 map：</p>\n<pre><code class=\"hljs GO\"><span class=\"hljs-keyword\">type</span> Indexers <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]IndexFunc\n\n<span class=\"hljs-keyword\">type</span> IndexFunc <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(obj <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span> <span class=\"hljs-params\">([]<span class=\"hljs-keyword\">string</span>, error)</span></span></code></pre>\n\n<p>Indexers 的 Key 是索引名称，值是 <em>根据资源对象创建计算该索引的索引值的函数</em></p>\n<p><code>Indices</code> 是存储倒排索引的数据结构：</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> Indices <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]Index\n\n<span class=\"hljs-keyword\">type</span> Index <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]sets.String</code></pre>\n\n<p>Indices 的 Key 是索引名, 值是对应的索引 Index<br>Index 的 Key 是索引值，值是具有该索引值的资源对象的 Key</p>\n<h2 id=\"KeyFunc-与-IndexFunc\"><a href=\"#KeyFunc-与-IndexFunc\" class=\"headerlink\" title=\"KeyFunc 与 IndexFunc\"></a>KeyFunc 与 IndexFunc</h2><p>KeyFunc 与 IndexFunc 对比如下：</p>\n<ul>\n<li>KeyFunc: f(obj) -&gt; key</li>\n<li>IndexFunc: f(obj) -&gt; indexValue1, indexValue2 …</li>\n</ul>\n<p>由上对比可知 KeyFunc 是 IndexFunc 的一个特例，当 IndexFunc 只返回一个索引值时它就退化为 KeyFunc，client-go 中也提供了由 IndexFunc 到 KeyFunc 的适配函数：</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">IndexFuncToKeyFuncAdapter</span><span class=\"hljs-params\">(indexFunc IndexFunc)</span> <span class=\"hljs-title\">KeyFunc</span></span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(obj <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">string</span>, error)</span></span> &#123;\n        indexKeys, err := indexFunc(obj)\n        <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>, err\n        &#125;\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(indexKeys) &gt; <span class=\"hljs-number\">1</span> &#123;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>, fmt.Errorf(<span class=\"hljs-string\">&quot;too many keys: %v&quot;</span>, indexKeys)\n        &#125;\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(indexKeys) == <span class=\"hljs-number\">0</span> &#123;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>, fmt.Errorf(<span class=\"hljs-string\">&quot;unexpected empty indexKeys&quot;</span>)\n        &#125;\n        <span class=\"hljs-keyword\">return</span> indexKeys[<span class=\"hljs-number\">0</span>], <span class=\"hljs-literal\">nil</span>\n    &#125;\n&#125;</code></pre>\n\n<p>常用的 KeyFunc 有 <code>MetaNamespaceKeyFunc</code>, 即 f(obj) -&gt; namespace/name<br>常用的 IndexFunc 则有 <code>MetaNamespaceIndexFunc</code>, 即 f(obj) -&gt; [namespace]</p>\n<h2 id=\"threadSafeMap\"><a href=\"#threadSafeMap\" class=\"headerlink\" title=\"threadSafeMap\"></a>threadSafeMap</h2><p><code>threadSafeMap</code> 是 <code>ThreadSafeStore</code> 的具体实现，通过 <code>sync.RWMutex</code> 实现线程安全。threadSafeMap 只能保证其定义的操作是线程安全的，直接对 Get/List 等操作返回的结果进行修改是无法保证的。</p>\n<p>threadSafeMap 的数据结构如下，它的增删查改操作主要就是操作 <code>items</code>，同时通过 indexers 计算资源对象在各个索引中的值，通过  <code>updateIndices</code> 和 <code>deleteFromIndices</code> 对 <code>indices</code> 进行更新。</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> threadSafeMap <span class=\"hljs-keyword\">struct</span> &#123;\n    lock  sync.RWMutex\n    items <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]<span class=\"hljs-keyword\">interface</span>&#123;&#125;\n\n    <span class=\"hljs-comment\">// indexers maps a name to an IndexFunc</span>\n    indexers Indexers\n    <span class=\"hljs-comment\">// indices maps a name to an Index</span>\n    indices Indices\n&#125;</code></pre>\n"},{"title":"Kubernetes 源码阅读 -- Expiring","date":"2021-01-02T13:54:45.000Z","_content":"\n## 概述\n\n[`Expiring`](https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/cache/expiring.go) 是 Kubernets 中的一个 **带有过期时间的键值对缓存**，位于 `k8s.io/apimachinery` 模块的 `pkg/util/cache` 包中。\n\n`Expiring` 具有以下功能与特性：\n\n- 可以存取任意类型的键值对\n- 键值对在过期后会被自动清除\n- 线程安全\n\n``` Go\n// 添加带过期时间的键值对\nfunc (c *Expiring) Set(key interface{}, val interface{}, ttl time.Duration)\n\n// 根据 key 获取 value\nfunc (c *Expiring) Get(key interface{}) (val interface{}, ok bool)\n\n// 根据 key 删除键值对\nfunc (c *Expiring) Delete(key interface{})\n\n// 获取 Expiring 中存储的键值对数量\nfunc (c *Expiring) Len()\n```\n\n## Expiring 的数据结构\n\n基于上述的功能与特性，`Expiring` 提供了以下方法：\n\n`Expiring` 的数据结构设计如下：\n\n``` Go\ntype Expiring struct {\n    // 时钟接口，使用该接口主要是为了便于测试\n    // 在 Expiring 中用到其中的 Now 方法，该方法可以直接看作 time.Now\n    clock utilclock.Clock\n    // 读写锁，用于保证线程安全\n    mu sync.RWMutex\n    // 实际存储键值对的数据结构\n    cache map[interface{}]entry\n    // 全局版本号，用来实现键值对过期时间的更新\n    generation uint64\n    // 存储过期时间的最小堆\n    heap expiringHeap\n}\n```\n\n其中 `entry` 的数据结构如下：\n\n``` Go\ntype entry struct {\n    // 用户输入的 value\n    val        interface{}\n    // 用户指定的过期时间\n    expiry     time.Time\n    // 存储当前键值对时 Expiring 的版本号\n    generation uint64\n}\n```\n\n### expiringHeap\n\n[`expiringHeap`](https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/cache/expiring.go#L168) 是一个存储键值对过期时间的最小堆，其数据结构如下：\n\n``` Go\ntype expiringHeap []*expiringHeapEntry\n\ntype expiringHeapEntry struct {\n    // 用户输入的 key\n    key        interface{}\n    // 过期时间\n    expiry     time.Time\n    // 存储当前键值对时 Expiring 的版本号\n    generation uint64\n}\n\n// expiringHeap 实现了 heap.Interface 接口\n// 即可以当作堆来使用\nvar _ heap.Interface = &expiringHeap{}\n\n// 比较的是过期时间\n// expiringHeapEntry 中的元素 i 小于 元素 j 当且仅当 i 的过期时间小于 j 的过期时间\nfunc (cq expiringHeap) Less(i, j int) bool {\n    return cq[i].expiry.Before(cq[j].expiry)\n}\n\n// heap.Interface 的其它方法的实现较为常见，在此忽略\n```\n\n## Expiring 的实现\n\n### Set\n\n``` Go\nfunc (c *Expiring) Set(key interface{}, val interface{}, ttl time.Duration) {\n    // 计算超时时间\n    now := c.clock.Now()\n    expiry := now.Add(ttl)\n\n    // 加写锁保证线程安全\n    c.mu.Lock()\n    defer c.mu.Unlock()\n\n    // 全局版本号自增\n    c.generation++\n\n    // 存储 value\n    c.cache[key] = entry{\n        val:        val,\n        expiry:     expiry,\n        generation: c.generation,\n    }\n\n    // 清理已过期的键值对\n    // Run GC inline before pushing the new entry.\n    c.gc(now)\n\n    // 过期时间存入最小堆中\n    heap.Push(&c.heap, &expiringHeapEntry{\n        key:        key,\n        expiry:     expiry,\n        generation: c.generation,\n    })\n}\n```\n\n#### Get\n\n``` Go\nfunc (c *Expiring) Get(key interface{}) (val interface{}, ok bool) {\n    // 加读锁保证线程安全\n    c.mu.RLock()\n    defer c.mu.RUnlock()\n    e, ok := c.cache[key]\n    if !ok || !c.clock.Now().Before(e.expiry) {\n        // 如果键值对存在但已过期则当作不存在返回\n        return nil, false\n    }\n    return e.val, true\n}\n```\n\n### 清理过期的键值对\n\n``` Go\n// 将 Expiring 所有过期的键值对清除\nfunc (c *Expiring) gc(now time.Time) {\n    for {\n        if len(c.heap) == 0 || now.Before(c.heap[0].expiry) {\n            // 因为过期时间的 entry 以最小堆的形式组织\n            // 所以如果第一个元素没有过期的话其余的元素也肯定没有过期\n            return\n        }\n        cleanup := heap.Pop(&c.heap).(*expiringHeapEntry)\n        // 执行清理操作\n        c.del(cleanup.key, cleanup.generation)\n    }\n}\n\nfunc (c *Expiring) del(key interface{}, generation uint64) {\n    e, ok := c.cache[key]\n    if !ok {\n        return\n    }\n    // generation == 0 标识该方法是由 Delete 调用的，键值对一定需要删除\n    // generation != 0 则说明该方法由 gc 调用\n    //      当 gc 调用该方法时如果该键值对在 cache 中存储的过期时间与在最小堆中存储的版本号不一致则说明\n    //      该键值对被更新过，当前的过期时间 entry 已经无效了，忽略就行（堆中还存在着该键值对的其它过期时间 entry）\n    if generation != 0 && generation != e.generation {\n        return\n    }\n    delete(c.cache, key)\n}\n\nfunc (c *Expiring) Delete(key interface{}) {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    c.del(key, 0)\n}\n```\n\n### utilclock.Clock\n\n在测试 `Expiring` 时，添加键值对需要指定过期时间，这可能导致测试时间变得很长，\n`Expiring` 中引入 [`utilclock.Clock`](https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/clock/clock.go) 能够让测试变得更加简单迅速。\n\n在实际使用时，`Expiring` 使用的是 [`RealClock`](https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/clock/clock.go#L43)，它使用的是真实的时间。\n\n而在测试时则可以使用 [`FakeClock`](https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/clock/clock.go#L85) 来 “快进” 到任意时间。\n\n下一篇文章将对 `Clock` 进行详细的介绍。\n","source":"_posts/Kubernetes-源码阅读-Expiring.md","raw":"---\ntitle: Kubernetes 源码阅读 -- Expiring\ndate: 2021-01-02 21:54:45\ntags: [k8s, 源码, cache, apimachinery]\ncategories: kubernetes\n---\n\n## 概述\n\n[`Expiring`](https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/cache/expiring.go) 是 Kubernets 中的一个 **带有过期时间的键值对缓存**，位于 `k8s.io/apimachinery` 模块的 `pkg/util/cache` 包中。\n\n`Expiring` 具有以下功能与特性：\n\n- 可以存取任意类型的键值对\n- 键值对在过期后会被自动清除\n- 线程安全\n\n``` Go\n// 添加带过期时间的键值对\nfunc (c *Expiring) Set(key interface{}, val interface{}, ttl time.Duration)\n\n// 根据 key 获取 value\nfunc (c *Expiring) Get(key interface{}) (val interface{}, ok bool)\n\n// 根据 key 删除键值对\nfunc (c *Expiring) Delete(key interface{})\n\n// 获取 Expiring 中存储的键值对数量\nfunc (c *Expiring) Len()\n```\n\n## Expiring 的数据结构\n\n基于上述的功能与特性，`Expiring` 提供了以下方法：\n\n`Expiring` 的数据结构设计如下：\n\n``` Go\ntype Expiring struct {\n    // 时钟接口，使用该接口主要是为了便于测试\n    // 在 Expiring 中用到其中的 Now 方法，该方法可以直接看作 time.Now\n    clock utilclock.Clock\n    // 读写锁，用于保证线程安全\n    mu sync.RWMutex\n    // 实际存储键值对的数据结构\n    cache map[interface{}]entry\n    // 全局版本号，用来实现键值对过期时间的更新\n    generation uint64\n    // 存储过期时间的最小堆\n    heap expiringHeap\n}\n```\n\n其中 `entry` 的数据结构如下：\n\n``` Go\ntype entry struct {\n    // 用户输入的 value\n    val        interface{}\n    // 用户指定的过期时间\n    expiry     time.Time\n    // 存储当前键值对时 Expiring 的版本号\n    generation uint64\n}\n```\n\n### expiringHeap\n\n[`expiringHeap`](https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/cache/expiring.go#L168) 是一个存储键值对过期时间的最小堆，其数据结构如下：\n\n``` Go\ntype expiringHeap []*expiringHeapEntry\n\ntype expiringHeapEntry struct {\n    // 用户输入的 key\n    key        interface{}\n    // 过期时间\n    expiry     time.Time\n    // 存储当前键值对时 Expiring 的版本号\n    generation uint64\n}\n\n// expiringHeap 实现了 heap.Interface 接口\n// 即可以当作堆来使用\nvar _ heap.Interface = &expiringHeap{}\n\n// 比较的是过期时间\n// expiringHeapEntry 中的元素 i 小于 元素 j 当且仅当 i 的过期时间小于 j 的过期时间\nfunc (cq expiringHeap) Less(i, j int) bool {\n    return cq[i].expiry.Before(cq[j].expiry)\n}\n\n// heap.Interface 的其它方法的实现较为常见，在此忽略\n```\n\n## Expiring 的实现\n\n### Set\n\n``` Go\nfunc (c *Expiring) Set(key interface{}, val interface{}, ttl time.Duration) {\n    // 计算超时时间\n    now := c.clock.Now()\n    expiry := now.Add(ttl)\n\n    // 加写锁保证线程安全\n    c.mu.Lock()\n    defer c.mu.Unlock()\n\n    // 全局版本号自增\n    c.generation++\n\n    // 存储 value\n    c.cache[key] = entry{\n        val:        val,\n        expiry:     expiry,\n        generation: c.generation,\n    }\n\n    // 清理已过期的键值对\n    // Run GC inline before pushing the new entry.\n    c.gc(now)\n\n    // 过期时间存入最小堆中\n    heap.Push(&c.heap, &expiringHeapEntry{\n        key:        key,\n        expiry:     expiry,\n        generation: c.generation,\n    })\n}\n```\n\n#### Get\n\n``` Go\nfunc (c *Expiring) Get(key interface{}) (val interface{}, ok bool) {\n    // 加读锁保证线程安全\n    c.mu.RLock()\n    defer c.mu.RUnlock()\n    e, ok := c.cache[key]\n    if !ok || !c.clock.Now().Before(e.expiry) {\n        // 如果键值对存在但已过期则当作不存在返回\n        return nil, false\n    }\n    return e.val, true\n}\n```\n\n### 清理过期的键值对\n\n``` Go\n// 将 Expiring 所有过期的键值对清除\nfunc (c *Expiring) gc(now time.Time) {\n    for {\n        if len(c.heap) == 0 || now.Before(c.heap[0].expiry) {\n            // 因为过期时间的 entry 以最小堆的形式组织\n            // 所以如果第一个元素没有过期的话其余的元素也肯定没有过期\n            return\n        }\n        cleanup := heap.Pop(&c.heap).(*expiringHeapEntry)\n        // 执行清理操作\n        c.del(cleanup.key, cleanup.generation)\n    }\n}\n\nfunc (c *Expiring) del(key interface{}, generation uint64) {\n    e, ok := c.cache[key]\n    if !ok {\n        return\n    }\n    // generation == 0 标识该方法是由 Delete 调用的，键值对一定需要删除\n    // generation != 0 则说明该方法由 gc 调用\n    //      当 gc 调用该方法时如果该键值对在 cache 中存储的过期时间与在最小堆中存储的版本号不一致则说明\n    //      该键值对被更新过，当前的过期时间 entry 已经无效了，忽略就行（堆中还存在着该键值对的其它过期时间 entry）\n    if generation != 0 && generation != e.generation {\n        return\n    }\n    delete(c.cache, key)\n}\n\nfunc (c *Expiring) Delete(key interface{}) {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    c.del(key, 0)\n}\n```\n\n### utilclock.Clock\n\n在测试 `Expiring` 时，添加键值对需要指定过期时间，这可能导致测试时间变得很长，\n`Expiring` 中引入 [`utilclock.Clock`](https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/clock/clock.go) 能够让测试变得更加简单迅速。\n\n在实际使用时，`Expiring` 使用的是 [`RealClock`](https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/clock/clock.go#L43)，它使用的是真实的时间。\n\n而在测试时则可以使用 [`FakeClock`](https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/clock/clock.go#L85) 来 “快进” 到任意时间。\n\n下一篇文章将对 `Clock` 进行详细的介绍。\n","slug":"Kubernetes-源码阅读-Expiring","published":1,"updated":"2021-01-02T15:46:57.823Z","_id":"ckjfvo33j00003ns6frt9bcsu","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><a href=\"https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/cache/expiring.go\"><code>Expiring</code></a> 是 Kubernets 中的一个 <strong>带有过期时间的键值对缓存</strong>，位于 <code>k8s.io/apimachinery</code> 模块的 <code>pkg/util/cache</code> 包中。</p>\n<p><code>Expiring</code> 具有以下功能与特性：</p>\n<ul>\n<li>可以存取任意类型的键值对</li>\n<li>键值对在过期后会被自动清除</li>\n<li>线程安全</li>\n</ul>\n<pre><code class=\"hljs Go\"><span class=\"hljs-comment\">// 添加带过期时间的键值对</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Set</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;, val <span class=\"hljs-keyword\">interface</span>&#123;&#125;, ttl time.Duration)</span></span>\n\n<span class=\"hljs-comment\">// 根据 key 获取 value</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Get</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span> <span class=\"hljs-params\">(val <span class=\"hljs-keyword\">interface</span>&#123;&#125;, ok <span class=\"hljs-keyword\">bool</span>)</span></span>\n\n<span class=\"hljs-comment\">// 根据 key 删除键值对</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Delete</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span></span>\n\n<span class=\"hljs-comment\">// 获取 Expiring 中存储的键值对数量</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Len</span><span class=\"hljs-params\">()</span></span></code></pre>\n\n<h2 id=\"Expiring-的数据结构\"><a href=\"#Expiring-的数据结构\" class=\"headerlink\" title=\"Expiring 的数据结构\"></a>Expiring 的数据结构</h2><p>基于上述的功能与特性，<code>Expiring</code> 提供了以下方法：</p>\n<p><code>Expiring</code> 的数据结构设计如下：</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> Expiring <span class=\"hljs-keyword\">struct</span> &#123;\n    <span class=\"hljs-comment\">// 时钟接口，使用该接口主要是为了便于测试</span>\n    <span class=\"hljs-comment\">// 在 Expiring 中用到其中的 Now 方法，该方法可以直接看作 time.Now</span>\n    clock utilclock.Clock\n    <span class=\"hljs-comment\">// 读写锁，用于保证线程安全</span>\n    mu sync.RWMutex\n    <span class=\"hljs-comment\">// 实际存储键值对的数据结构</span>\n    cache <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">interface</span>&#123;&#125;]entry\n    <span class=\"hljs-comment\">// 全局版本号，用来实现键值对过期时间的更新</span>\n    generation <span class=\"hljs-keyword\">uint64</span>\n    <span class=\"hljs-comment\">// 存储过期时间的最小堆</span>\n    heap expiringHeap\n&#125;</code></pre>\n\n<p>其中 <code>entry</code> 的数据结构如下：</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> entry <span class=\"hljs-keyword\">struct</span> &#123;\n    <span class=\"hljs-comment\">// 用户输入的 value</span>\n    val        <span class=\"hljs-keyword\">interface</span>&#123;&#125;\n    <span class=\"hljs-comment\">// 用户指定的过期时间</span>\n    expiry     time.Time\n    <span class=\"hljs-comment\">// 存储当前键值对时 Expiring 的版本号</span>\n    generation <span class=\"hljs-keyword\">uint64</span>\n&#125;</code></pre>\n\n<h3 id=\"expiringHeap\"><a href=\"#expiringHeap\" class=\"headerlink\" title=\"expiringHeap\"></a>expiringHeap</h3><p><a href=\"https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/cache/expiring.go#L168\"><code>expiringHeap</code></a> 是一个存储键值对过期时间的最小堆，其数据结构如下：</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> expiringHeap []*expiringHeapEntry\n\n<span class=\"hljs-keyword\">type</span> expiringHeapEntry <span class=\"hljs-keyword\">struct</span> &#123;\n    <span class=\"hljs-comment\">// 用户输入的 key</span>\n    key        <span class=\"hljs-keyword\">interface</span>&#123;&#125;\n    <span class=\"hljs-comment\">// 过期时间</span>\n    expiry     time.Time\n    <span class=\"hljs-comment\">// 存储当前键值对时 Expiring 的版本号</span>\n    generation <span class=\"hljs-keyword\">uint64</span>\n&#125;\n\n<span class=\"hljs-comment\">// expiringHeap 实现了 heap.Interface 接口</span>\n<span class=\"hljs-comment\">// 即可以当作堆来使用</span>\n<span class=\"hljs-keyword\">var</span> _ heap.Interface = &amp;expiringHeap&#123;&#125;\n\n<span class=\"hljs-comment\">// 比较的是过期时间</span>\n<span class=\"hljs-comment\">// expiringHeapEntry 中的元素 i 小于 元素 j 当且仅当 i 的过期时间小于 j 的过期时间</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(cq expiringHeap)</span> <span class=\"hljs-title\">Less</span><span class=\"hljs-params\">(i, j <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">bool</span></span> &#123;\n    <span class=\"hljs-keyword\">return</span> cq[i].expiry.Before(cq[j].expiry)\n&#125;\n\n<span class=\"hljs-comment\">// heap.Interface 的其它方法的实现较为常见，在此忽略</span></code></pre>\n\n<h2 id=\"Expiring-的实现\"><a href=\"#Expiring-的实现\" class=\"headerlink\" title=\"Expiring 的实现\"></a>Expiring 的实现</h2><h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Set</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;, val <span class=\"hljs-keyword\">interface</span>&#123;&#125;, ttl time.Duration)</span></span> &#123;\n    <span class=\"hljs-comment\">// 计算超时时间</span>\n    now := c.clock.Now()\n    expiry := now.Add(ttl)\n\n    <span class=\"hljs-comment\">// 加写锁保证线程安全</span>\n    c.mu.Lock()\n    <span class=\"hljs-keyword\">defer</span> c.mu.Unlock()\n\n    <span class=\"hljs-comment\">// 全局版本号自增</span>\n    c.generation++\n\n    <span class=\"hljs-comment\">// 存储 value</span>\n    c.cache[key] = entry&#123;\n        val:        val,\n        expiry:     expiry,\n        generation: c.generation,\n    &#125;\n\n    <span class=\"hljs-comment\">// 清理已过期的键值对</span>\n    <span class=\"hljs-comment\">// Run GC inline before pushing the new entry.</span>\n    c.gc(now)\n\n    <span class=\"hljs-comment\">// 过期时间存入最小堆中</span>\n    heap.Push(&amp;c.heap, &amp;expiringHeapEntry&#123;\n        key:        key,\n        expiry:     expiry,\n        generation: c.generation,\n    &#125;)\n&#125;</code></pre>\n\n<h4 id=\"Get\"><a href=\"#Get\" class=\"headerlink\" title=\"Get\"></a>Get</h4><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Get</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span> <span class=\"hljs-params\">(val <span class=\"hljs-keyword\">interface</span>&#123;&#125;, ok <span class=\"hljs-keyword\">bool</span>)</span></span> &#123;\n    <span class=\"hljs-comment\">// 加读锁保证线程安全</span>\n    c.mu.RLock()\n    <span class=\"hljs-keyword\">defer</span> c.mu.RUnlock()\n    e, ok := c.cache[key]\n    <span class=\"hljs-keyword\">if</span> !ok || !c.clock.Now().Before(e.expiry) &#123;\n        <span class=\"hljs-comment\">// 如果键值对存在但已过期则当作不存在返回</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, <span class=\"hljs-literal\">false</span>\n    &#125;\n    <span class=\"hljs-keyword\">return</span> e.val, <span class=\"hljs-literal\">true</span>\n&#125;</code></pre>\n\n<h3 id=\"清理过期的键值对\"><a href=\"#清理过期的键值对\" class=\"headerlink\" title=\"清理过期的键值对\"></a>清理过期的键值对</h3><pre><code class=\"hljs Go\"><span class=\"hljs-comment\">// 将 Expiring 所有过期的键值对清除</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">gc</span><span class=\"hljs-params\">(now time.Time)</span></span> &#123;\n    <span class=\"hljs-keyword\">for</span> &#123;\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(c.heap) == <span class=\"hljs-number\">0</span> || now.Before(c.heap[<span class=\"hljs-number\">0</span>].expiry) &#123;\n            <span class=\"hljs-comment\">// 因为过期时间的 entry 以最小堆的形式组织</span>\n            <span class=\"hljs-comment\">// 所以如果第一个元素没有过期的话其余的元素也肯定没有过期</span>\n            <span class=\"hljs-keyword\">return</span>\n        &#125;\n        cleanup := heap.Pop(&amp;c.heap).(*expiringHeapEntry)\n        <span class=\"hljs-comment\">// 执行清理操作</span>\n        c.del(cleanup.key, cleanup.generation)\n    &#125;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">del</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;, generation <span class=\"hljs-keyword\">uint64</span>)</span></span> &#123;\n    e, ok := c.cache[key]\n    <span class=\"hljs-keyword\">if</span> !ok &#123;\n        <span class=\"hljs-keyword\">return</span>\n    &#125;\n    <span class=\"hljs-comment\">// generation == 0 标识该方法是由 Delete 调用的，键值对一定需要删除</span>\n    <span class=\"hljs-comment\">// generation != 0 则说明该方法由 gc 调用</span>\n    <span class=\"hljs-comment\">//      当 gc 调用该方法时如果该键值对在 cache 中存储的过期时间与在最小堆中存储的版本号不一致则说明</span>\n    <span class=\"hljs-comment\">//      该键值对被更新过，当前的过期时间 entry 已经无效了，忽略就行（堆中还存在着该键值对的其它过期时间 entry）</span>\n    <span class=\"hljs-keyword\">if</span> generation != <span class=\"hljs-number\">0</span> &amp;&amp; generation != e.generation &#123;\n        <span class=\"hljs-keyword\">return</span>\n    &#125;\n    <span class=\"hljs-built_in\">delete</span>(c.cache, key)\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Delete</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span></span> &#123;\n    c.mu.Lock()\n    <span class=\"hljs-keyword\">defer</span> c.mu.Unlock()\n    c.del(key, <span class=\"hljs-number\">0</span>)\n&#125;</code></pre>\n\n<h3 id=\"utilclock-Clock\"><a href=\"#utilclock-Clock\" class=\"headerlink\" title=\"utilclock.Clock\"></a>utilclock.Clock</h3><p>在测试 <code>Expiring</code> 时，添加键值对需要指定过期时间，这可能导致测试时间变得很长，<br><code>Expiring</code> 中引入 <a href=\"https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/clock/clock.go\"><code>utilclock.Clock</code></a> 能够让测试变得更加简单迅速。</p>\n<p>在实际使用时，<code>Expiring</code> 使用的是 <a href=\"https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/clock/clock.go#L43\"><code>RealClock</code></a>，它使用的是真实的时间。</p>\n<p>而在测试时则可以使用 <a href=\"https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/clock/clock.go#L85\"><code>FakeClock</code></a> 来 “快进” 到任意时间。</p>\n<p>下一篇文章将对 <code>Clock</code> 进行详细的介绍。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><a href=\"https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/cache/expiring.go\"><code>Expiring</code></a> 是 Kubernets 中的一个 <strong>带有过期时间的键值对缓存</strong>，位于 <code>k8s.io/apimachinery</code> 模块的 <code>pkg/util/cache</code> 包中。</p>\n<p><code>Expiring</code> 具有以下功能与特性：</p>\n<ul>\n<li>可以存取任意类型的键值对</li>\n<li>键值对在过期后会被自动清除</li>\n<li>线程安全</li>\n</ul>\n<pre><code class=\"hljs Go\"><span class=\"hljs-comment\">// 添加带过期时间的键值对</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Set</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;, val <span class=\"hljs-keyword\">interface</span>&#123;&#125;, ttl time.Duration)</span></span>\n\n<span class=\"hljs-comment\">// 根据 key 获取 value</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Get</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span> <span class=\"hljs-params\">(val <span class=\"hljs-keyword\">interface</span>&#123;&#125;, ok <span class=\"hljs-keyword\">bool</span>)</span></span>\n\n<span class=\"hljs-comment\">// 根据 key 删除键值对</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Delete</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span></span>\n\n<span class=\"hljs-comment\">// 获取 Expiring 中存储的键值对数量</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Len</span><span class=\"hljs-params\">()</span></span></code></pre>\n\n<h2 id=\"Expiring-的数据结构\"><a href=\"#Expiring-的数据结构\" class=\"headerlink\" title=\"Expiring 的数据结构\"></a>Expiring 的数据结构</h2><p>基于上述的功能与特性，<code>Expiring</code> 提供了以下方法：</p>\n<p><code>Expiring</code> 的数据结构设计如下：</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> Expiring <span class=\"hljs-keyword\">struct</span> &#123;\n    <span class=\"hljs-comment\">// 时钟接口，使用该接口主要是为了便于测试</span>\n    <span class=\"hljs-comment\">// 在 Expiring 中用到其中的 Now 方法，该方法可以直接看作 time.Now</span>\n    clock utilclock.Clock\n    <span class=\"hljs-comment\">// 读写锁，用于保证线程安全</span>\n    mu sync.RWMutex\n    <span class=\"hljs-comment\">// 实际存储键值对的数据结构</span>\n    cache <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">interface</span>&#123;&#125;]entry\n    <span class=\"hljs-comment\">// 全局版本号，用来实现键值对过期时间的更新</span>\n    generation <span class=\"hljs-keyword\">uint64</span>\n    <span class=\"hljs-comment\">// 存储过期时间的最小堆</span>\n    heap expiringHeap\n&#125;</code></pre>\n\n<p>其中 <code>entry</code> 的数据结构如下：</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> entry <span class=\"hljs-keyword\">struct</span> &#123;\n    <span class=\"hljs-comment\">// 用户输入的 value</span>\n    val        <span class=\"hljs-keyword\">interface</span>&#123;&#125;\n    <span class=\"hljs-comment\">// 用户指定的过期时间</span>\n    expiry     time.Time\n    <span class=\"hljs-comment\">// 存储当前键值对时 Expiring 的版本号</span>\n    generation <span class=\"hljs-keyword\">uint64</span>\n&#125;</code></pre>\n\n<h3 id=\"expiringHeap\"><a href=\"#expiringHeap\" class=\"headerlink\" title=\"expiringHeap\"></a>expiringHeap</h3><p><a href=\"https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/cache/expiring.go#L168\"><code>expiringHeap</code></a> 是一个存储键值对过期时间的最小堆，其数据结构如下：</p>\n<pre><code class=\"hljs Go\"><span class=\"hljs-keyword\">type</span> expiringHeap []*expiringHeapEntry\n\n<span class=\"hljs-keyword\">type</span> expiringHeapEntry <span class=\"hljs-keyword\">struct</span> &#123;\n    <span class=\"hljs-comment\">// 用户输入的 key</span>\n    key        <span class=\"hljs-keyword\">interface</span>&#123;&#125;\n    <span class=\"hljs-comment\">// 过期时间</span>\n    expiry     time.Time\n    <span class=\"hljs-comment\">// 存储当前键值对时 Expiring 的版本号</span>\n    generation <span class=\"hljs-keyword\">uint64</span>\n&#125;\n\n<span class=\"hljs-comment\">// expiringHeap 实现了 heap.Interface 接口</span>\n<span class=\"hljs-comment\">// 即可以当作堆来使用</span>\n<span class=\"hljs-keyword\">var</span> _ heap.Interface = &amp;expiringHeap&#123;&#125;\n\n<span class=\"hljs-comment\">// 比较的是过期时间</span>\n<span class=\"hljs-comment\">// expiringHeapEntry 中的元素 i 小于 元素 j 当且仅当 i 的过期时间小于 j 的过期时间</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(cq expiringHeap)</span> <span class=\"hljs-title\">Less</span><span class=\"hljs-params\">(i, j <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">bool</span></span> &#123;\n    <span class=\"hljs-keyword\">return</span> cq[i].expiry.Before(cq[j].expiry)\n&#125;\n\n<span class=\"hljs-comment\">// heap.Interface 的其它方法的实现较为常见，在此忽略</span></code></pre>\n\n<h2 id=\"Expiring-的实现\"><a href=\"#Expiring-的实现\" class=\"headerlink\" title=\"Expiring 的实现\"></a>Expiring 的实现</h2><h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Set</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;, val <span class=\"hljs-keyword\">interface</span>&#123;&#125;, ttl time.Duration)</span></span> &#123;\n    <span class=\"hljs-comment\">// 计算超时时间</span>\n    now := c.clock.Now()\n    expiry := now.Add(ttl)\n\n    <span class=\"hljs-comment\">// 加写锁保证线程安全</span>\n    c.mu.Lock()\n    <span class=\"hljs-keyword\">defer</span> c.mu.Unlock()\n\n    <span class=\"hljs-comment\">// 全局版本号自增</span>\n    c.generation++\n\n    <span class=\"hljs-comment\">// 存储 value</span>\n    c.cache[key] = entry&#123;\n        val:        val,\n        expiry:     expiry,\n        generation: c.generation,\n    &#125;\n\n    <span class=\"hljs-comment\">// 清理已过期的键值对</span>\n    <span class=\"hljs-comment\">// Run GC inline before pushing the new entry.</span>\n    c.gc(now)\n\n    <span class=\"hljs-comment\">// 过期时间存入最小堆中</span>\n    heap.Push(&amp;c.heap, &amp;expiringHeapEntry&#123;\n        key:        key,\n        expiry:     expiry,\n        generation: c.generation,\n    &#125;)\n&#125;</code></pre>\n\n<h4 id=\"Get\"><a href=\"#Get\" class=\"headerlink\" title=\"Get\"></a>Get</h4><pre><code class=\"hljs Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Get</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span> <span class=\"hljs-params\">(val <span class=\"hljs-keyword\">interface</span>&#123;&#125;, ok <span class=\"hljs-keyword\">bool</span>)</span></span> &#123;\n    <span class=\"hljs-comment\">// 加读锁保证线程安全</span>\n    c.mu.RLock()\n    <span class=\"hljs-keyword\">defer</span> c.mu.RUnlock()\n    e, ok := c.cache[key]\n    <span class=\"hljs-keyword\">if</span> !ok || !c.clock.Now().Before(e.expiry) &#123;\n        <span class=\"hljs-comment\">// 如果键值对存在但已过期则当作不存在返回</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, <span class=\"hljs-literal\">false</span>\n    &#125;\n    <span class=\"hljs-keyword\">return</span> e.val, <span class=\"hljs-literal\">true</span>\n&#125;</code></pre>\n\n<h3 id=\"清理过期的键值对\"><a href=\"#清理过期的键值对\" class=\"headerlink\" title=\"清理过期的键值对\"></a>清理过期的键值对</h3><pre><code class=\"hljs Go\"><span class=\"hljs-comment\">// 将 Expiring 所有过期的键值对清除</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">gc</span><span class=\"hljs-params\">(now time.Time)</span></span> &#123;\n    <span class=\"hljs-keyword\">for</span> &#123;\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(c.heap) == <span class=\"hljs-number\">0</span> || now.Before(c.heap[<span class=\"hljs-number\">0</span>].expiry) &#123;\n            <span class=\"hljs-comment\">// 因为过期时间的 entry 以最小堆的形式组织</span>\n            <span class=\"hljs-comment\">// 所以如果第一个元素没有过期的话其余的元素也肯定没有过期</span>\n            <span class=\"hljs-keyword\">return</span>\n        &#125;\n        cleanup := heap.Pop(&amp;c.heap).(*expiringHeapEntry)\n        <span class=\"hljs-comment\">// 执行清理操作</span>\n        c.del(cleanup.key, cleanup.generation)\n    &#125;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">del</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;, generation <span class=\"hljs-keyword\">uint64</span>)</span></span> &#123;\n    e, ok := c.cache[key]\n    <span class=\"hljs-keyword\">if</span> !ok &#123;\n        <span class=\"hljs-keyword\">return</span>\n    &#125;\n    <span class=\"hljs-comment\">// generation == 0 标识该方法是由 Delete 调用的，键值对一定需要删除</span>\n    <span class=\"hljs-comment\">// generation != 0 则说明该方法由 gc 调用</span>\n    <span class=\"hljs-comment\">//      当 gc 调用该方法时如果该键值对在 cache 中存储的过期时间与在最小堆中存储的版本号不一致则说明</span>\n    <span class=\"hljs-comment\">//      该键值对被更新过，当前的过期时间 entry 已经无效了，忽略就行（堆中还存在着该键值对的其它过期时间 entry）</span>\n    <span class=\"hljs-keyword\">if</span> generation != <span class=\"hljs-number\">0</span> &amp;&amp; generation != e.generation &#123;\n        <span class=\"hljs-keyword\">return</span>\n    &#125;\n    <span class=\"hljs-built_in\">delete</span>(c.cache, key)\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Expiring)</span> <span class=\"hljs-title\">Delete</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span></span> &#123;\n    c.mu.Lock()\n    <span class=\"hljs-keyword\">defer</span> c.mu.Unlock()\n    c.del(key, <span class=\"hljs-number\">0</span>)\n&#125;</code></pre>\n\n<h3 id=\"utilclock-Clock\"><a href=\"#utilclock-Clock\" class=\"headerlink\" title=\"utilclock.Clock\"></a>utilclock.Clock</h3><p>在测试 <code>Expiring</code> 时，添加键值对需要指定过期时间，这可能导致测试时间变得很长，<br><code>Expiring</code> 中引入 <a href=\"https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/clock/clock.go\"><code>utilclock.Clock</code></a> 能够让测试变得更加简单迅速。</p>\n<p>在实际使用时，<code>Expiring</code> 使用的是 <a href=\"https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/clock/clock.go#L43\"><code>RealClock</code></a>，它使用的是真实的时间。</p>\n<p>而在测试时则可以使用 <a href=\"https://github.com/kubernetes/apimachinery/blob/v0.20.1/pkg/util/clock/clock.go#L85\"><code>FakeClock</code></a> 来 “快进” 到任意时间。</p>\n<p>下一篇文章将对 <code>Clock</code> 进行详细的介绍。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckgkztjut0000uffybu9e6o28","category_id":"ckgkztjux0001uffy77h0ep4s","_id":"ckgkztjuz0004uffyg6s35ppx"},{"post_id":"ckjfvo33j00003ns6frt9bcsu","category_id":"ckgkztjux0001uffy77h0ep4s","_id":"ckjfvo33p00023ns65q4y4a1p"}],"PostTag":[{"post_id":"ckgkztjut0000uffybu9e6o28","tag_id":"ckgkztjuy0002uffyfb8oglm8","_id":"ckgkztjuz0006uffy5a988avh"},{"post_id":"ckgkztjut0000uffybu9e6o28","tag_id":"ckgkztjuy0003uffy5tnw7krg","_id":"ckgkztjv00007uffyatv30kvo"},{"post_id":"ckgkztjut0000uffybu9e6o28","tag_id":"ckgkztjuz0005uffyd5so14v5","_id":"ckgkztjv00008uffy4k1oc2fu"},{"post_id":"ckjfvo33j00003ns6frt9bcsu","tag_id":"ckgkztjuy0002uffyfb8oglm8","_id":"ckjfvo33q00043ns69xpgf0cs"},{"post_id":"ckjfvo33j00003ns6frt9bcsu","tag_id":"ckgkztjuy0003uffy5tnw7krg","_id":"ckjfvo33q00053ns6dboxciw2"},{"post_id":"ckjfvo33j00003ns6frt9bcsu","tag_id":"ckjfvo33o00013ns6hgkg8fwf","_id":"ckjfvo33q00063ns6dzzx625c"},{"post_id":"ckjfvo33j00003ns6frt9bcsu","tag_id":"ckjfvo33q00033ns6584jfbio","_id":"ckjfvo33q00073ns6150305ku"}],"Tag":[{"name":"k8s","_id":"ckgkztjuy0002uffyfb8oglm8"},{"name":"源码","_id":"ckgkztjuy0003uffy5tnw7krg"},{"name":"client-go","_id":"ckgkztjuz0005uffyd5so14v5"},{"name":"cache","_id":"ckjfvo33o00013ns6hgkg8fwf"},{"name":"apimachinery","_id":"ckjfvo33q00033ns6584jfbio"}]}}